\section{Simple encryptor}
Keywords: circular shift


\begin{verbatim}

undefined8 main(void)

{
  int r_1;
  time_t t_epoch;
  long in_FS_OFFSET;
  uint epoch;
  uint r_2;
  long i;
  FILE *file_in;
  size_t file_offset;
  void *buffer;
  FILE *file_out;
  long cannary;
  
  cannary = *(long *)(in_FS_OFFSET + 0x28);
  file_in = fopen("flag","rb");
  fseek(file_in,0,2);
  file_offset = ftell(file_in);
  fseek(file_in,0,0);
  buffer = malloc(file_offset);
  fread(buffer,file_offset,1,file_in);
  fclose(file_in);
  t_epoch = time((time_t *)0x0);
  epoch = (uint)t_epoch;
  srand(epoch);
  for (i = 0; i < (long)file_offset; i = i + 1) {
    r_1 = rand();
    *(byte *)((long)buffer + i) = *(byte *)((long)buffer + i) ^ (byte)r_1;
    r_2 = rand();
    r_2 = r_2 & 7;
    *(byte *)((long)buffer + i) =
         *(byte *)((long)buffer + i) << (sbyte)r_2 | *(byte *)((long)buffer + i) >> 8 - (sbyte)r_2;
  }
  file_out = fopen("flag.enc","wb");
  fwrite(&epoch,1,4,file_out);
  fwrite(buffer,1,file_offset,file_out);
  fclose(file_out);
  if (cannary != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
\end{verbatim}

donc il charge le fichier flag dans un buffer. Il initialise le random gen avec
\verb+seed+ en utilisant \verb+srand+

\verb+srand+ function sets its argument as the seed for a new sequence of
pseudo-random integers to be returned by \verb+rand()+.  {\bf These sequences
are repeatable by calling srand() with the same seed value.}

il chiffre byte par byte le fichier avec la logique (traité après) 
puis écrit \verb+seed+ suivi du fichier chiffré.


la logique qu'il faut reverse est la:
\begin{verbatim}
  for (i = 0; i < (long)file_offset; i = i + 1) {
    r_1 = rand();
    *(byte *)((long)buffer + i) = *(byte *)((long)buffer + i) ^ (byte)r_1;
    r_2 = rand();
    r_2 = r_2 & 7;
    *(byte *)((long)buffer + i) =
         *(byte *)((long)buffer + i) << (sbyte)r_2 | *(byte *)((long)buffer + i) >> 8 - (sbyte)r_2;
  }
\end{verbatim}

\begin{verbatim}
  for (i = 0; i < (long)file_offset; i = i + 1) {
    r_1 = rand();
    buffer[i] = buffer[i] ^ (byte)r_1;
    r_2 = rand();
    r_2 = r_2 & 7;
    buffer[i] = buffer[i] << (sbyte)r_2 | buffer[i] >> 8 -(sbyte)r_2;
  }
\end{verbatim}

\begin{verbatim}
& bitwise AND
| bitwise inclusive OR
^ bitwise exclusive OR
<< left shift
>> right shift
~ one's complement (unary)
\end{verbatim}

\verb+x = x | SET_ON;+ sets to one in \verb+x+ the bits that are set to one in
\verb+SET_ON+.

The bitwise exclusive OR operator \verb+^+ sets a one in each bit position where its operands have
different bits, and zero where they are the same.

\begin{verbatim}
QWORD PTR [rbp-0x8] = canary
QWORD PTR [rbp-0x18] = &buffer (QWORD)
QWORD PTR [rbp-0x20] = size (QWORD)
QWORD PTR [rbp-0x28] = file_in (QWORD)
QWORD PTR [rbp-0x30] = i (QWORD)
QWORD PTR [rbp-0x34] = ? (DWORD) 
QWORD PTR [rbp-0x39] = save (BYTE)

\begin{verbatim}
0x01346 <+189>:   mov    QWORD PTR [rbp-0x30],0x0  ; i = 
0x0134e <+197>:   jmp    0x13c0 <main+311>         
0x01350 <+199>:   call   0x1190 <rand@plt>
;;;;; start loop
0x01355 <+204>:   movzx  ecx,al                   ; ecx = (byte)rand(<++>)
;;;;;;;
; DEBUT buffer[i] = buffer[i] xor rand()
;;;;;;;
0x01358 <+207>:   mov    rdx,QWORD PTR [rbp-0x30]
0x0135c <+211>:   mov    rax,QWORD PTR [rbp-0x18]
0x01360 <+215>:   add    rax,rdx                  ; rax = & buffer + i
0x01363 <+218>:   movzx  eax,BYTE PTR [rax]       ; eax = buffer[i]
0x01366 <+221>:   mov    edx,eax                  ; edx = buffer[i]
0x01368 <+223>:   mov    eax,ecx                  
0x0136a <+225>:   mov    ecx,edx                 
0x0136c <+227>:   xor    ecx,eax                  ; xor buffer[i] rand
0x0136e <+229>:   mov    rdx,QWORD PTR [rbp-0x30]
0x01372 <+233>:   mov    rax,QWORD PTR [rbp-0x18]
0x01376 <+237>:   add    rax,rdx
0x01379 <+240>:   mov    edx,ecx                  
0x0137b <+242>:   mov    BYTE PTR [rax],dl        ; buffer[i] = xor buffer[i](char)rand()
;;;;;;;
; FIN buffer[i] = buffer[i] xor rand()
;;;;;;;

0x0137d <+244>:   call   0x1190 <rand@plt>
0x01382 <+249>:   and    eax,0x7
0x01385 <+252>:   mov    ecx,eax                      ; ecx = rand() & 7

0x01387 <+254>:   mov    rdx,QWORD PTR [rbp-0x30]
0x0138b <+258>:   mov    rax,QWORD PTR [rbp-0x18]
0x0138f <+262>:   add    rax,rdx                      ; rax = & buffer + i

0x01392 <+265>:   movzx  eax,BYTE PTR [rax]           ; eax = buffer[i]
0x01395 <+268>:   movzx  eax,al                       ; eax = buffer[i]

0x01398 <+271>:   mov    rsi,QWORD PTR [rbp-0x30]
0x0139c <+275>:   mov    rdx,QWORD PTR [rbp-0x18]
0x013a0 <+279>:   add    rdx,rsi                     ; rdx = & buffer +i

0x013a3 <+282>:   mov    BYTE PTR [rbp-0x39],al      ; s = buffer[i]
0x013a6 <+285>:   mov    DWORD PTR [rbp-0x34],ecx    ; r = rand() & 7
0x013a9 <+288>:   movzx  eax,BYTE PTR [rbp-0x39]     ; eax = buffer[i]
0x013ad <+292>:   mov    esi,eax                     ; esi = buffer[i]
0x013af <+294>:   mov    eax,DWORD PTR [rbp-0x34]    ; eax =  rand() & 7
0x013b2 <+297>:   mov    ecx,eax                     ; ecx = rand() & 7
0x013b4 <+299>:   rol    sil,cl                      ; rol buffer[i], rand() & 7
0x013b7 <+302>:   mov    eax,esi
0x013b9 <+304>:   mov    BYTE PTR [rdx],al            ; buffer[i] = rol buffer[i], rand() & 7


0x013bb <+306>:   add    QWORD PTR [rbp-0x30],0x1     ; check loop cond
0x013c0 <+311>:   mov    rax,QWORD PTR [rbp-0x30]     
0x013c4 <+315>:   cmp    rax,QWORD PTR [rbp-0x20]     
0x013c8 <+319>:   jl     0x1350 <main+199>

\end{verbatim}


\verb+rol+: Cette instruction permet d'effectuer une rotation des bits vers la
gauche en réinsérant le bit dans le bit le plus à droite libéré.

\href{https://en.wikipedia.org/wiki/Circular_shift#Implementing_circular_shifts}{circular
shift}

\begin{verbatim}
var = (var << shift) | (var >> (sizeof(var)*CHAR_BIT-shift))
\end{verbatim}

donc on a bien un traitement byte par byte
\begin{verbatim}
for (i = 0 ; i < size ; i++){
    buffer[i] = buffer[i] ^ (char)rand();
    buffer[i] = rol buffer[i], rand() & 7
}
\end{verbatim}

donc il faudrait faire un 
\begin{verbatim}
for (i = 0 ; i < size ; i++){
    buffer[i] = ror buffer[i], rand() & 7
    r = rand() & 7
    buffer[i] = buffer[i] >> (byte)r | buffer[i] << 8 -(byte)r;
    buffer[i] = buffer[i] ^ (char)rand();
}
\end{verbatim}

le vrai code est le suivant :
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>

int
main(int argc, char *argv[]){
  int r_1;
  time_t t_epoch;
  long in_FS_OFFSET;
  uint seed;
  uint r_2;
  long i;
  FILE *file_in;
  size_t size, r;
  char *buffer;
  FILE *file_out;

  file_in = fopen("./flag.enc","rb");
  if (file_in == NULL) {
    printf("can't open");
    return EXIT_FAILURE;
  }

  fseek(file_in,0,2);
  size = ftell(file_in);
  size -= 4;
  fseek(file_in,0,0);
  r =  fread(&seed,4,1,file_in);
  srand(seed);

  buffer = malloc(size);
  r = fread(buffer,1 , size, file_in);
  for(i = 0; i < size; i++) {
    r_1 = rand();
    r_2 = rand() & 7;
    buffer[i] = ((unsigned char)buffer[i] >> r_2) | (buffer[i] << (8 - r_2));
    buffer[i] = buffer[i] ^ (char)r_1;
  }
  printf("%s\n\r", buffer);
  free(buffer);
  fclose(file_in);
  return EXIT_SUCCESS;
}
\end{verbatim}

on notera la subtilité 
\begin{verbatim}
    buffer[i] = ((unsigned char)buffer[i] >> r_2) | (buffer[i] << (8 - r_2));
\end{verbatim}
