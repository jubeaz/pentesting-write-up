\section{Exalton}

\begin{verbatim}
$ file exatlon_v1
exatlon_v1: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux),
statically linked, no section header
\end{verbatim}

etrange le fichier n'est ni stripped ni not stripped et pas de section header.

en cherchant sur internet on peut essayer de voir si le fichier est compressé

\begin{verbatim}
$ strings exatlon_v1 |grep UPX
UPX!<
$Info: This file is packed with the UPX executable packer http://upx.sf.net $
$Id: UPX 3.95 Copyright (C) 1996-2018 the UPX Team. All Rights Reserved. $
UPX!u
UPX!
UPX!
$ upx -d exatlon_v1
$ readelf -a ./exatlon_v1  | more
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 03 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - GNU
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x404990
  Start of program headers:          64 (bytes into file)
  Start of section headers:          2200584 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         8
  Size of section headers:           64 (bytes)
  Number of section headers:         31
\end{verbatim}

dans Ghidra on cherche \verb+Enter Exatlon Password+ et on remonte sur la ref
d'utilisation
\verb+00404cf+ qui fait un cout

après on a un \verb+cin+

\begin{verbatim}
      00404cf0 48 8d 35      LEA       RSI,[s_[+]_Enter_Exatlon_Password_:_0054b  = "[+] Enter Exatlon Passwor
               d9 67 14
               00
      00404cf7 48 8d 3d      LEA       RDI,[std::cout]                            = ??
               82 68 1a
               00
                         try { // try from 00404cfe to 00404dce has its CatchH
                         LAB_00404cfe                              XREF[1]:   005971d9(*)
      00404cfe e8 4d 37      CALL      std::operator<<                            basic_ostream * operator<<(b
               06 00
      00404d03 48 8d 45      LEA       RAX=>local_58,[RBP + -0x50]
               b0
      00404d07 48 89 c6      MOV       RSI,RAX
      00404d0a 48 8d 3d      LEA       RDI,[std::cin]                             = ??
               8f 69 1a
               00
      00404d11 e8 7a 20      CALL      std::operator>>                            basic_istream * operator>>(b
               00 00
      00404d16 48 8d 45      LEA       RAX=>local_38,[RBP + -0x30]
               d0
      00404d1a 48 8d 55      LEA       RDX=>local_58,[RBP + -0x50]
               b0
      00404d1e 48 89 d6      MOV       RSI,RDX
      00404d21 48 89 c7      MOV       RDI,RAX
      00404d24 e8 84 fd      CALL      exatlon                                    undefined exatlon(basic_stri
               ff ff
      00404d29 48 8d 45      LEA       RAX=>local_38,[RBP + -0x30]
               d0
      00404d2d 48 8d 35      LEA       RSI,[s_1152_1344_1056_1968_1728_816_164_0  = "1152 1344 1056 1968 1728 
               bc 67 14 
               00
      00404d34 48 89 c7      MOV       RDI,RAX
      00404d37 e8 be 03      CALL      std::operator==                            bool operator==(basic_string
               00 00
      00404d3c 89 c3         MOV       EBX,EAX
      00404d3e 48 8d 45      LEA       RAX=>local_38,[RBP + -0x30]
               d0
      00404d42 48 89 c7      MOV       RDI,RAX
      00404d45 e8 e6 85      CALL      std::__cxx11::basic_string<char,std::char  undefined ~basic_string(basi
               06 00
      00404d4a 84 db         TEST      BL,BL
      00404d4c 74 35         JZ        LAB_00404d83
      00404d4e 48 8d 35      LEA       RSI,[s_[+]_Looks_Good_^_^_0054b59b]        = "[+] Looks Good ^_^ \n\n\n"
               46 68 14 
               00
\end{verbatim}

ca ressemble a du \verb+c+++

l'instruction à l'addresse \verb+0x00404d4c+ semble interessante.

\begin{verbatim}
pwndbg> b *0x00404d4a
Breakpoint 1 at 0x404d4a
pwndbg> r
Starting program: 

[+] Enter Exatlon Password  : aaa

Breakpoint 1, 0x0000000000404d4a in main ()

pwndbg> i r flags
Invalid register `flags'
pwndbg> i r rflags
Invalid register `rflags'
pwndbg> i r eflags
eflags         0x246               [ PF ZF IF ]
pwndbg> s
0x0000000000404d4c in main ()

pwndbg> i r eflags
eflags         0x246               [ PF ZF IF ]
pwndbg> set $eflags &= ~(1 << $ZF)
Argument to arithmetic operation not a number or boolean.
pwndbg> set $ZF = 6
pwndbg> set $eflags &= ~(1 << $ZF)

pwndbg> i r eflags
eflags         0x206               [ PF IF ]
pwndbg> c
Continuing.
[+] Looks Good ^_^
[Inferior 1 (process 1742089) exited normally]
\end{verbatim}

juste avant l'appel de \verb+std::operator==+ \verb+rdi+ input et \verb+rsi+
password:
\begin{verbatim}
 RDI  0x7fffffffbf90 — 0x7fffffffbfa0 — '1552 1552 1552 '
 RSI  0x54b4f0 — '1152 1344 1056 1968 1728 816 1648 784 1584 816 1728 1520
 1840 1664 784 1632 1856 1520 1728 816 1632 1856 1520 784 1760 1840 1824 816
 1584 1856 784 1776 1760 528 528 2000 '
\end{verbatim}

sachant que j'ai saisi \verb+aaa+

d'après ghidra \verb+rsi+ est un pointeur sur un \verb+basic_string+

\verb+0046f1d0+ on call \verb+compare+

\verb+0046f20+ appel de \verb+bcmp+ compare byte sequences: 
\begin{verbatim}
0x46f1fe    mov    rdi, qword ptr [r12]
0x46f202    mov    rsi, r13
0x46f205    call   0x401020
\end{verbatim}

en fait la fonction \verb+exalton+ semble chiffrer notre chaine et la comparer
à une chaine chiffrée.

\begin{verbatim}
HTB_[_a} => 1152 1344 1056 1520 1456 1520 1552 2000 
\end{verbatim}

donc il faut esperer que la fonction soit reversible.

la fonction en question
\begin{verbatim}
basic_string * exatlon(basic_string *param_1)

{
  bool bVar1;
  char *pcVar2;
  basic_string<char,std::char_traits<char>,std::allocator<char>> *in_RSI;
  undefined8 local_80;
  undefined8 local_78;
  allocator<char> local_69;
  basic_string local_68 [32];
  __cxx11 local_48 [39];
  char local_21;
  basic_string<char,std::char_traits<char>,std::allocator<char>> *local_20;

  std::allocator<char>::allocator();
                    /* try { // try from 00404ae8 to 00404aec has its CatchHandler @ 00404bc1 */
  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string
            ((char *)param_1,(allocator *)&DAT_0054b00c);
  std::allocator<char>::~allocator(&local_69);
  local_20 = in_RSI;
  local_78 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::begin
                       (in_RSI);
  local_80 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::end
                       (local_20);
  while( true ) {
    bVar1 = __gnu_cxx::operator!=((__normal_iterator *)&local_78,(__normal_iterator *)&local_80);
    if (!bVar1) break;
    pcVar2 = (char *)__gnu_cxx::
                     __normal_iterator<char_const*,std::__cxx11::basic_string<char,std::char_traits< char>,std::allocator<char>>>
                     ::operator*((__normal_iterator<char_const*,std::__cxx11::basic_string<char,std: :char_traits<char>,std::allocator<char>>>
                                  *)&local_78);
    local_21 = *pcVar2;
                    /* try { // try from 00404b63 to 00404b67 has its CatchHandler @ 00404bfd */
    std::__cxx11::to_string(local_48,(int)local_21 << 4);
                    /* try { // try from 00404b7d to 00404b81 has its CatchHandler @ 00404bec */
    std::operator+(local_68,(char *)local_48);
                    /* try { // try from 00404b93 to 00404b97 has its CatchHandler @ 00404bdb */
    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=
              ((basic_string<char,std::char_traits<char>,std::allocator<char>> *)param_1,local_68);
    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string
              ((basic_string<char,std::char_traits<char>,std::allocator<char>> *)local_68);
    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string
              ((basic_string<char,std::char_traits<char>,std::allocator<char>> *)local_48);
    __gnu_cxx::
    __normal_iterator<char_const*,std::__cxx11::basic_string<char,std::char_traits<char>,std::alloca tor<char>>>
    ::operator++((__normal_iterator<char_const*,std::__cxx11::basic_string<char,std::char_traits<cha r>,std::allocator<char>>>
                  *)&local_78);
  }
  return param_1;
}
\end{verbatim}

la fonction semble donc modifier la valeur d'entrée caractere par caractere.

on va essayer d'entrer un jeu de caractere et voir commment ils sont traduit 1
à 1 et voir ce que l'on decode sur la chaine d'entrée.

\begin{verbatim}
[+] Enter Exatlon Password  : HTB{_0123456789azertyuiopqsdfghjklmwxcvbn}
*RDI  0x7fffffffbf90 — 0x5c3140 — 0x3433312032353131 ('1152 134')
pwndbg> x/s 0x5c3140
0x5c3140:       "1152 1344 1056 1968 1520 768 784 800 816 832 848 864 880 896 912 1552 1952 1616 1824 1856 1936 1872 1680 1776 1792 1808 1840 1600 1632 1648 1664 1696 1712 1728 1744 1904 1920 1584 1888 1568 1760 2000 "
 0x7fffffffbf70 — 0x5c3010 — 'HTB{_0123456789azertyuiopqsdfghjklmwxcvbn}'
\end{verbatim}

donc 
\begin{verbatim}
'1152 1344 1056 1968 1728 816 1648 784 1584 816 1728 1520 1840 1664 784 1632 
  H     T   B    {    l    3    g   1    c   3   l    _     s    h   1   f
1856 1520 1728 816 1632 1856 1520 784 1760 1840 1824 816 1584 1856 784 1776 1760 
 t    _    l    3   f    t     _   1    n    s    r   3   c    t    1    o    n
528 528 2000 '
         }
\end{verbatim}

