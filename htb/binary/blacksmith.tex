\chapter{Blacksmith}
\begin{itemize}
    \item {\bf technics}: 
    \item {\bf tools}: 
\end{itemize}


\section{Résumé}

\section{Analysis}
\subsection{File info}
\begin{verbatim}
$ file blacksmith | tr ',' '\n' |tr ':' '\n'
blacksmith
 ELF 64-bit LSB pie executable
 x86-64
 version 1 (SYSV)
 dynamically linked
 interpreter /lib64/ld-linux-x86-64.so.2
 for GNU/Linux 3.2.0
 BuildID[sha1]=a4acbf7f1d36cdce46b8fe897a8ac56d49236d29
 not stripped
\end{verbatim}

\subsection{Security}
\begin{verbatim}
$ pwntools-pwn checksec --file=./blacksmith
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      PIE enabled
    RWX:      Has RWX segments
\end{verbatim}

Full RELRO pas bon  mais  NX disable donc \verb+ret2stack+ avec canarie

donc il faut trouver un \verb+printf+ qui va permettre de leak le canary puis
un overflow

\subsection{Execution}


\section{static analysis}
\subsection{main}

\subsubsection{Decompilation}
\begin{verbatim}
\end{verbatim}

\subsubsection{desassemblage}
\begin{verbatim}
\end{verbatim}

\subsubsection{Analyse}



\subsection{sword and bow}
Elles sont similaires

\subsubsection{Decompilation}
\begin{verbatim}
void sword(void)
{
  size_t __n;
  long in_FS_OFFSET;
  long canarie;
  
  canarie = *(long *)(in_FS_OFFSET + 0x28);
  __n = strlen(
              "This sword can cut through anything! The only thing is, that it is too heavy carry it ..\n"
              );
  write(1,
        "This sword can cut through anything! The only thing is, that it is too heavy carry it..\n",
        __n);
  if (canarie != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}
\end{verbatim}

\subsubsection{desassemblage}
\begin{verbatim}
   0x0000000000000ca4 <+0>:	push   rbp
   0x0000000000000ca5 <+1>:	mov    rbp,rsp
   0x0000000000000ca8 <+4>:	sub    rsp,0x10
   0x0000000000000cac <+8>:	mov    rax,QWORD PTR fs:0x28
   0x0000000000000cb5 <+17>:	mov    QWORD PTR [rbp-0x8],rax
   0x0000000000000cb9 <+21>:	xor    eax,eax
   0x0000000000000cbb <+23>:	lea    rax,[rip+0x2f6]        # 0xfb8
   0x0000000000000cc2 <+30>:	mov    QWORD PTR [rbp-0x10],rax
   0x0000000000000cc6 <+34>:	mov    rax,QWORD PTR [rbp-0x10]
   0x0000000000000cca <+38>:	mov    rdi,rax
   0x0000000000000ccd <+41>:	call   0x9b0 <strlen@plt>
   0x0000000000000cd2 <+46>:	mov    rdx,rax
   0x0000000000000cd5 <+49>:	mov    rax,QWORD PTR [rbp-0x10]
   0x0000000000000cd9 <+53>:	mov    rsi,rax
   0x0000000000000cdc <+56>:	mov    edi,0x1
   0x0000000000000ce1 <+61>:	call   0x990 <write@plt>
   0x0000000000000ce6 <+66>:	nop
   0x0000000000000ce7 <+67>:	mov    rax,QWORD PTR [rbp-0x8]
   0x0000000000000ceb <+71>:	xor    rax,QWORD PTR fs:0x28
   0x0000000000000cf4 <+80>:	je     0xcfb <sword+87>
   0x0000000000000cf6 <+82>:	call   0x9c0 <__stack_chk_fail@plt>
   0x0000000000000cfb <+87>:	leave  
   0x0000000000000cfc <+88>:	ret   
\end{verbatim}

\subsubsection{Analyse}
rien à faire

\subsection{shield}
\subsubsection{Decompilation}
\begin{verbatim}
void shield(void)
{
  size_t sVar1;
  long in_FS_OFFSET;
  undefined buffer [72];
  long canarie;

  canarie = *(long *)(in_FS_OFFSET + 0x28);
  sVar1 = strlen(&DAT_00101080);
  write(1,&DAT_00101080,sVar1);
  sVar1 = strlen("Do you like your new weapon?\n> ");
  write(1,"Do you like your new weapon?\n> ",sVar1);
  read(0,buffer,0x3f);
  (*(code *)buffer)();
  if (canarie != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}
\end{verbatim}

\subsubsection{desassemblage}
\begin{verbatim}
   0x0000000000000d56 <+0>:	push   rbp
   0x0000000000000d57 <+1>:	mov    rbp,rsp
   0x0000000000000d5a <+4>:	sub    rsp,0x60
   0x0000000000000d5e <+8>:	mov    rax,QWORD PTR fs:0x28
   0x0000000000000d67 <+17>:	mov    QWORD PTR [rbp-0x8],rax
   0x0000000000000d6b <+21>:	xor    eax,eax
   0x0000000000000d6d <+23>:	lea    rax,[rip+0x30c]        # 0x1080
   0x0000000000000d74 <+30>:	mov    QWORD PTR [rbp-0x60],rax
   0x0000000000000d78 <+34>:	lea    rax,[rip+0x399]        # 0x1118
   0x0000000000000d7f <+41>:	mov    QWORD PTR [rbp-0x58],rax
   0x0000000000000d83 <+45>:	mov    rax,QWORD PTR [rbp-0x60]
   0x0000000000000d87 <+49>:	mov    rdi,rax
   0x0000000000000d8a <+52>:	call   0x9b0 <strlen@plt>
   0x0000000000000d8f <+57>:	mov    rdx,rax
   0x0000000000000d92 <+60>:	mov    rax,QWORD PTR [rbp-0x60]
   0x0000000000000d96 <+64>:	mov    rsi,rax
   0x0000000000000d99 <+67>:	mov    edi,0x1
   0x0000000000000d9e <+72>:	call   0x990 <write@plt>
   0x0000000000000da3 <+77>:	mov    rax,QWORD PTR [rbp-0x58]
   0x0000000000000da7 <+81>:	mov    rdi,rax
   0x0000000000000daa <+84>:	call   0x9b0 <strlen@plt>
   0x0000000000000daf <+89>:	mov    rdx,rax
   0x0000000000000db2 <+92>:	mov    rax,QWORD PTR [rbp-0x58]
   0x0000000000000db6 <+96>:	mov    rsi,rax
   0x0000000000000db9 <+99>:	mov    edi,0x1
   0x0000000000000dbe <+104>:	call   0x990 <write@plt>
   0x0000000000000dc3 <+109>:	lea    rax,[rbp-0x50]
   0x0000000000000dc7 <+113>:	mov    edx,0x3f
   0x0000000000000dcc <+118>:	mov    rsi,rax
   0x0000000000000dcf <+121>:	mov    edi,0x0
   0x0000000000000dd4 <+126>:	call   0x9e0 <read@plt>
   0x0000000000000dd9 <+131>:	lea    rdx,[rbp-0x50]
   0x0000000000000ddd <+135>:	mov    eax,0x0
   0x0000000000000de2 <+140>:	call   rdx
   0x0000000000000de4 <+142>:	nop
   0x0000000000000de5 <+143>:	mov    rax,QWORD PTR [rbp-0x8]
   0x0000000000000de9 <+147>:	xor    rax,QWORD PTR fs:0x28
   0x0000000000000df2 <+156>:	je     0xdf9 <shield+163>
   0x0000000000000df4 <+158>:	call   0x9c0 <__stack_chk_fail@plt>
   0x0000000000000df9 <+163>:	leave
   0x0000000000000dfa <+164>:	ret
\end{verbatim}
\subsubsection{analyse}

donc on appel une fonction donc l'addresse est contenue dans le buffer


\section{Exploit}

\subsection{Strategy}


\subsection{Exploit build}


\begin{verbatim}
$ pwntools-pwn template --host 10.10.10.10 --port 10 ./ > pwn-bin.py
\end{verbatim}


