\section{Secret Rezipe}
Keywords: 



application Node

il va falloir deviner un uuid v4

\begin{verbatim}
crypto.randomUUID([options])
#
Added in: v14.17.0

    options <Object>
        disableEntropyCache <boolean> By default, to improve performance, Node.js generates and caches enough random data to generate up to 128 random UUIDs. To generate a UUID without using the cache, set disableEntropyCache to true. Defaults: false.
    Returns: <string>

Generates a random RFC 4122 version 4 UUID. The UUID is generated using a cryptographic pseudorandom number generator.
\end{verbatim}


non visiblement cela ne va pas être ca.

l'autre truc c'est que l'on a une injection dans le fichier zip

\href{https://users.cs.jmu.edu/buchhofp/forensics/formats/pkzip.html}{The
structure of a PKZip file}

ce que l'on fait c'est que le zip contient
\verb+Secret: HTB{+ + qqchoe + \verb+}+ + un input ou rien

En toute logique si l'on injecte une chaine qui n'est pas le flag. La taille du
zip devrait êtrei (trop) supérieure. on devrait donc avoir la possibilité de bruteforce
le contenu.


\begin{verbatim}
$ xxd ingredients-empty.zip
00000000: 504b 0304 0a00 0900 0000 5d23 2b56 7557  PK........]#+VuW
00000010: 53d1 2e00 0000 2200 0000 3400 1c00 746d  S....."...4...tm
\end{verbatim}

la taille est donc \verb+2e00 0000+

Si on inject \verb+Secret: HTB{fake_flag_for_testing}+
\begin{verbatim}
$ xxd ingredients-final.zip
00000000: 504b 0304 1400 0900 0800 b524 2b56 89a4  PK.........$+V..
00000010: 9e08 3400 0000 4500 0000 3400 1c00 746d  ..4...E...4...tm
\end{verbatim}


On n'a pas la même taille.


si on ject \verb+Secret: HTB+ 
\begin{verbatim}
$ xxd ingredients-1.zip 
00000000: 504b 0304 1400 0900 0800 2f24 2b56 f960  PK......../$+V.`
00000010: ca4a 3400 0000 2e00 0000 3400 1c00 746d  .J4.......4...tm
\end{verbatim}

on a par contre la même taille que si l'on avait injecté la bonne chaine.

si on ject \verb+Secret: HTB{+ 
\begin{verbatim}
 xxd ingredients-2.zip 
00000000: 504b 0304 1400 0900 0800 5924 2b56 e1c7  PK........Y$+V..
00000010: fed1 3400 0000 2f00 0000 3400 1c00 746d  ..4.../...4...tm
\end{verbatim}

encore une fois même taille que si doublon parfait

si on ject \verb+Secret: HTB_+ 
\begin{verbatim}
$ xxd ingredients-3.zip 
00000000: 504b 0304 1400 0900 0800 8924 2b56 3023  PK.........$+V0#
00000010: fded 3500 0000 2f00 0000 3400 1c00 746d  ..5.../...4...tm
\end{verbatim}


donc on va pouvoir faire un script de bruteforce

\begin{verbatim}
#!/usr/bin/env python3

import requests
import string
import json
import zipfile
import io

ip = '104.248.175.144'
port = 32170

headers = {'Content-Type': 'application/json'}
url = f'http://{ip}:{port}/ingredients'

base = 'Secret: HTB'
base_false = 'Secret: HTB_'

all_char = string.ascii_letters + string.digits + '{' + '}' + '_'

def req_file(content):
    payload = {'ingredients': content}
    #rint(json.dumps(payload))
    r = requests.post(url, data=json.dumps(payload), headers=headers, stream=True)
    if r.status_code != 200:
        raise Exception(r.status_code)
    #print(r.content)
    zip = zipfile.ZipFile(io.BytesIO(r.content))
    l = zip.infolist()
    return l[0].compress_size

    
#req_file('')
#req_file('Secret:')
size_true = req_file(base)
req_file(base_false)

def brute_char(content):
    for i in all_char:
        size = req_file(content + i)
        if size == size_true:
            return content + i
    raise Exception("can't find char")

flag = base 
while True:
    flag = brute_char(flag) 
    print(flag)
\end{verbatim}

\begin{verbatim}
Secret: HTB{
Secret: HTB{C
Secret: HTB{C0
Secret: HTB{C0m
Secret: HTB{C0mp
Secret: HTB{C0mpr
Secret: HTB{C0mpr3
Secret: HTB{C0mpr3s
Secret: HTB{C0mpr3sS
Secret: HTB{C0mpr3sSi
Secret: HTB{C0mpr3sSi0
Secret: HTB{C0mpr3sSi0n
Secret: HTB{C0mpr3sSi0n_
Secret: HTB{C0mpr3sSi0n_1
Secret: HTB{C0mpr3sSi0n_1s
Secret: HTB{C0mpr3sSi0n_1s_
Secret: HTB{C0mpr3sSi0n_1s_n
Secret: HTB{C0mpr3sSi0n_1s_n0
Secret: HTB{C0mpr3sSi0n_1s_n0t
Secret: HTB{C0mpr3sSi0n_1s_n0t_
Secret: HTB{C0mpr3sSi0n_1s_n0t_3
Secret: HTB{C0mpr3sSi0n_1s_n0t_3N
Secret: HTB{C0mpr3sSi0n_1s_n0t_3Nc
Secret: HTB{C0mpr3sSi0n_1s_n0t_3Ncr
Secret: HTB{C0mpr3sSi0n_1s_n0t_3Ncry
Secret: HTB{C0mpr3sSi0n_1s_n0t_3NcryP
Secret: HTB{C0mpr3sSi0n_1s_n0t_3NcryPt
Secret: HTB{C0mpr3sSi0n_1s_n0t_3NcryPti
Secret: HTB{C0mpr3sSi0n_1s_n0t_3NcryPti0
Secret: HTB{C0mpr3sSi0n_1s_n0t_3NcryPti0n
Secret: HTB{C0mpr3sSi0n_1s_n0t_3NcryPti0n}
Traceback (most recent call last):
\end{verbatim}



