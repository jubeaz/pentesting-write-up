\section{Baby Time Capsule}


\begin{verbatim}
from Crypto.Util.number import bytes_to_long, getPrime
import socketserver
import json

FLAG = b'HTB{--REDACTED--}'


class TimeCapsule():
    def __init__(self, msg):
        self.msg = msg
        self.bit_size = 1024
        self.e = 5

    def _get_new_pubkey(self):
        while True:
            p = getPrime(self.bit_size // 2)
            q = getPrime(self.bit_size // 2)
            n = p * q
            phi = (p - 1) * (q - 1)
            try:
                pow(self.e, -1, phi)
                break
            except ValueError:
                pass
        return n, self.e

    def get_new_time_capsule(self):
        n, e = self._get_new_pubkey()
        m = bytes_to_long(self.msg)
        m = pow(m, e, n)
        return {"time_capsule": f"{m:X}", "pubkey": [f"{n:X}", f"{e:X}"]}


def challenge(req):
    time_capsule = TimeCapsule(FLAG)
    while True:
        try:
            req.sendall(
                b'Welcome to Qubit Enterprises. Would you like your own time capsule? (Y/n) '
            )
            msg = req.recv(4096).decode().strip().upper()
            if msg == 'Y' or msg == 'YES':
                capsule = time_capsule.get_new_time_capsule()
                req.sendall(json.dumps(capsule).encode() + b'\n')
            elif msg == 'N' or msg == "NO":
                req.sendall(b'Thank you, take care\n')
                break
            else:
                req.sendall(b'I\'m sorry I don\'t understand\n')
        except:
            # Socket closed, bail
            return


class MyTCPRequestHandler(socketserver.BaseRequestHandler):

    def handle(self):
        req = self.request
        challenge(req)

class ThreadingTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
    pass

def main():
    socketserver.TCPServer.allow_reuse_address = True
    server = ThreadingTCPServer(("0.0.0.0", 1337), MyTCPRequestHandler)
    server.serve_forever()

if __name__ == '__main__':
    main()
\end{verbatim}

\begin{verbatim}
io = start()
io.sendlineafter('Y/n) ', 'Y')
str = io.recvline().decode()
print(str)
\end{verbatim}

\begin{verbatim}
{"time_capsule": "756025CE34269CAFF8F5B8E29B1A9ACA7BAE08764A652E48CD56CD46F0393B7F2281A76C92D49E4911FFCB1B42E96E42CFB7E203CDE9AE0C827460C081876CDFF6F069066149A8285E21515B37608363E4D8905B9ED3D9D755EF5C8C2C4425DE8EAE5E0BF68A0D9CF63B98489FBC4997B1D9A60C5B8EBD505965BAB77A780FF6", "pubkey": ["93CB6830ABCE2C9F215DC2C5A0641D5E9ECA0CCFED3B931E0AB6C8E2181A29F932CF600AD350D75F3F0682D17A6E3F9E337CD4AA4F8605749D3D68B639D19C06612976349FF9DE6BFBA3FC4096BC2E6EB5F188C43CCACD4C5506116F31286288DE2A2E9679F651DD714705A184E59DAC2E5F2DDAD49654C9CC73AFE42C5A9989", "5"]}

\end{verbatim}


donc cela ressemble à du RSA et comme le même contenu est retransmis à chaque
appel avec une clé publique différente, on peut faire une attaque à la chinoise
;)

\begin{verbatim}
from sympy.ntheory.modular import crt
from sympy import integer_nthroot
from Crypto.Util.number import long_to_bytes

flag_1 = 0x284C.. .SNIP. ..F2B21098BD971EF0151CE21
n_1 = 0xEBC238B14DB.. .SNIP. ..447F3523916E129

flag_2 = ''
n_2= ''

flag_3 = ''
n_3 = ''

x = crt([n1, n2, n3], [flag_1, flag_2, flag_3], check=True)
print("x=", x)

m = integer_nthroot(x[0], 5)
print("m=", m)

flag = long_to_bytes(m[0])
print("flag=", flag)
\end{verbatim}
